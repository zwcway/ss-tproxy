#!/bin/bash

\trap "exit 1" HUP INT QUIT TERM PIPE

PATH=$PATH:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin

readonly bin="${0##*/}"
base_dir="${0%/*}"
ss_tproxy_config="$base_dir/ss-tproxy.conf"

declare -a __optentries=()
declare -a __proxy_svripv4=()
declare -a __proxy_svripv6=()

__proxy_schema=
__proxy_uri_list=()
__dnsmasq_common_config=

readonly IPV4_RESERVED_IPADDRS=(
    0.0.0.0/8
    10.0.0.0/8
    100.64.0.0/10
    127.0.0.0/8
    169.254.0.0/16
    172.16.0.0/12
    192.0.0.0/24
    192.0.2.0/24
    192.88.99.0/24
    192.168.0.0/16
    198.18.0.0/15
    198.51.100.0/24
    203.0.113.0/24
    224.0.0.0/4
    240.0.0.0/4
    255.255.255.255/32
)

readonly IPV6_RESERVED_IPADDRS=(
    ::/128
    ::1/128
    ::ffff:0:0/96
    ::ffff:0:0:0/96
    64:ff9b::/96
    100::/64
    2001::/32
    2001:20::/28
    2001:db8::/32
    2002::/16
    fc00::/7
    fe80::/10
    ff00::/8
)

readonly IPV4_PATTERN='^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+'
readonly IPV6_PATTERN='^((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?$'
readonly DOMAIN_PATTERN='^[a-z0-9]([-_a-z0-9]+\.){1,}[a-z]+'

readonly IPV4_NET_PATTERN=$IPV4_PATTERN'(/[0-9]+|/'$IPV4_PATTERN')?$'
readonly IPV6_NET_PATTERN=$IPV6_PATTERN'(/[0-9]+)?$'

font_bold()     { \printf "\e[1m$*\e[0m";    }
color_red()     { \printf "\e[31m$*\e[0m";   }
color_green()   { \printf "\e[32m$*\e[0m";   }
color_yellow()  { \printf "\e[33m$*\e[0m";   }
color_white()   { \printf "\e[37m$*\e[0m";   }

log_fault() { \echo "$(font_bold $(color_yellow '[ERROR]')) $*" 1>&2 ; exit 1;  }
log_error() { \echo "$(font_bold $(color_yellow '[ERROR]')) $*" 1>&2 ;          }

is_true()           { [[ "$1" = 'true' ]];      }
is_false()          { [[ "$1" = 'false' ]];     }
file_is_exists()    { [[ -f "$1" ]];            }

load_config() {
    file_is_exists "$ss_tproxy_config" || log_fault "file not found: $ss_tproxy_config"

	local __base_dir="$base_dir"
    #save_config "$ss_tproxy_config" base_dir "'$base_dir'"
    \source "$ss_tproxy_config" "${@}" || log_fault "load config failed, exit-code: $?"

    ## default value
    base_dir="${base_dir:-$__base_dir}"
    mode=${mode:-gfwlist}
    ipv4=${ipv4:-true}
    ipv6=${ipv6:-false}
    tproxy=${tproxy:-false}
    tcponly=${tcponly:-false}
    selfonly=${selfonly:-false}
    dns_direct=${dns_direct:-114.114.114.114}
    dns_direct6=${dns_direct6:-240C::6666}
    dns_remote=${dns_remote:-8.8.8.8#53}
    dns_remote6=${dns_remote6:-2001:4860:4860::8888#53}

    proxy_uri=${proxy_uri:-}
    __proxy_uri_list=${!proxy_uri@}
    proxy_log_enable=${proxy_log_enable:-false}
    proxy_log_file=${proxy_log_file:-$base_dir/v2ray.log}
    proxy_log_level=${proxy_log_level:-warning}
    proxy_startcmd=${proxy_startcmd:-}
    proxy_stopcmd=${proxy_stopcmd:-}
    proxy_srvport=${proxy_srvport:-}
    proxy_local=${proxy_local:-false}
    proxy_tcpport=${proxy_tcpport:-60080}
    proxy_udpport=${proxy_udpport:-60080}

    is_variable_defined proxy_srvaddr4 || proxy_srvaddr4=()
    is_variable_array proxy_srvaddr4 || proxy_srvaddr4=("$proxy_srvaddr4")
    is_variable_defined proxy_srvaddr6 || proxy_srvaddr6=()
    is_variable_array proxy_srvaddr6 || proxy_srvaddr6=("$proxy_srvaddr6")

    file_dnsserver_pid="${file_dnsserver_pid:-$base_dir/.dnsserver.pid}"
    dnsmasq_bind_port=${dnsmasq_bind_port:-53}
    dnsmasq_cache_size=${dnsmasq_cache_size:-4096}
    dnsmasq_cache_time=${dnsmasq_cache_time:-3600}
    dnsmasq_query_maxcnt=${dnsmasq_query_maxcnt:-32}
    dnsmasq_log_enable=${dnsmasq_log_enable:-false}
    dnsmasq_log_file="${dnsmasq_log_file:-$base_dir/proxy.log}"
    dnsmasq_log_level="${dnsmasq_log_level:-warning}"
    dnsmasq_config_file="${dnsmasq_config_file:-$base_dir/dnsmasq.conf}"
    dnsmasq_gfwlist_file="${dnsmasq_gfwlist_file:-$base_dir/dnsmasq.gfwlist.conf}"
    dnsmasq_ignore_file="${dnsmasq_ignore_file:-$base_dir/dnsmasq.ignore.conf}"
    is_variable_defined dnsmasq_conf_dir || dnsmasq_conf_dir=()
    is_variable_array dnsmasq_conf_dir || dnsmasq_conf_dir=("$dnsmasq_conf_dir")
    is_variable_defined dnsmasq_conf_file || dnsmasq_conf_file=()
    is_variable_array dnsmasq_conf_file || dnsmasq_conf_file=("$dnsmasq_conf_file")
    is_variable_defined dnsmasq_conf_string || dnsmasq_conf_string=()
    is_variable_array dnsmasq_conf_string || dnsmasq_conf_string=("$dnsmasq_conf_string")

    chinadns_bind_port=${chinadns_bind_port:-65353}
    chinadns_timeout=${chinadns_timeout:-3}
    chinadns_repeat=${chinadns_repeat:-1}
    chinadns_fairmode=${chinadns_fairmode:-false}
    chinadns_gfwlist_mode=${chinadns_gfwlist_mode:-false}
    chinadns_noip_as_chnip=${chinadns_noip_as_chnip:-false}
    chinadns_verbose=${chinadns_verbose:-false}
    chinadns_logfile="${chinadns_logfile:-$base_dir/chinadns.log}"
    is_variable_defined chinadns_privaddr4 || chinadns_privaddr4=()
    is_variable_array chinadns_privaddr4 || chinadns_privaddr4=("$chinadns_privaddr4")
    is_variable_defined chinadns_privaddr6 || chinadns_privaddr6=()
    is_variable_array chinadns_privaddr6 || chinadns_privaddr6=("$chinadns_privaddr6")

    dns2tcp_bind_port=${dns2tcp_bind_port:-65454}
    dns2tcp_verbose=${dns2tcp_verbose:-false}
    dns2tcp_logfile=${dns2tcp_logfile:-$base_dir/dns2tcp.log}

    ipts_if_lo=${ipts_if_lo:-lo}
    ipts_rt_tab=${ipts_rt_tab:-233}
    ipts_rt_mark=${ipts_rt_mark:-0x2333}
    ipts_set_snat=${ipts_set_snat:-true}
    ipts_set_snat6=${ipts_set_snat6:-true}
    ipts_reddns_onstop=${ipts_reddns_onstop:-true}
    ipts_proxy_dst_port=${ipts_proxy_dst_port:-1:65535}

    opts_ss_netstat=${opts_ss_netstat:-auto}
    opts_ping_cmd_to_use=${opts_ping_cmd_to_use:-auto}
    opts_hostname_resolver=${opts_hostname_resolver:-auto}
    opts_overwrite_resolv=${opts_overwrite_resolv:-false}
    opts_ip_for_check_net=${opts_ip_for_check_net:-}

    ipset_privaddr_name=${ipset_privaddr_name:-privaddr}
    ipset_gfwlist_name=${ipset_gfwlist_name:-gfwlist}
    ipset_chnroute_name=${ipset_chnroute_name:-chnroute}
    ipset_timeout=${ipset_timeout:-604800}

    file_gfwlist_txt="${file_gfwlist_txt:-$base_dir/gfwlist.txt}"
    file_gfwlist_ext="${file_gfwlist_ext:-$base_dir/gfwlist.ext}"
    file_ignlist_ext="${file_ignlist_ext:-$base_dir/ignlist.ext}"
    file_chnroute_set="${file_chnroute_set:-$base_dir/chnroute.set}"
    file_chnroute6_set="${file_chnroute6_set:-$base_dir/chnroute6.set}"

    v2ray_config_file="${v2ray_config_file:-$base_dir/v2ray.conf}"
    ssr_config_file="${ssr_config_file:-$base_dir/shadowsocks.conf}"

    bin_v2ray="${bin_v2ray:-}"
    bin_ssr="${bin_ssr:-}"
    bin_ss="${bin_ss:-}"

    bin_iptables="${bin_iptables:-}"
    bin_ip6tables="${bin_iptables:-}"
    bin_dnsmasq="${bin_dnsmasq:-}"
    bin_chinadnsng="${bin_chinadnsng:-}"
    bin_dns2tcp="${bin_dns2tcp:-}"


    bin_netstat=
    bin_base64_decode=
    func_resolver=
    bin_ping4=
    bin_ping6=

    status_dnsmasq_pid=
    status_chinadns_pid=
    status_dns2tcp4_pid=
    status_dns2tcp6_pid=
    status_v2ray_pid=
    status_ss_pid=

    local args="" key= val=
    for optentry in ${__optentries[@]}; do
        key=$(\cut -d= -f1 <<<"$optentry")
        var=$(\cut -d= -f2 <<<"$optentry")
        [ -z "$key" ] && continue
        [ -z "$var" ] && var="''"
        config_check_allow_override $key || continue
        eval "$optentry";
        args="$args ${key} ${var}"
    done
    [ -n "$args" ] && save_config "$ss_tproxy_config" $args
}

command_is_exists()     { \which "$1" &>/dev/null;           }
process_is_running()    { [ "$1" -gt '0' ] && \kill -0 "$1" &>/dev/null;         }
tcp_port_is_exists()    { $bin_netstat -lnpt | \grep -qE ":$1[ \t]"; }
udp_port_is_exists()    { $bin_netstat -anpu | \grep -qE ":$1[ \t]"; }

parse_schema() { \cut -d: -f1 <<<"$1" ; }
url_query()     { \grep -oE "\b$1=[^&]*" <<<"$2" | cut -d= -f2; }

chk_dnsserver_is_started() {
    process_is_running "$status_dnsmasq_pid"  ||
    process_is_running "$status_chinadns_pid" ||
    process_is_running "$status_dns2tcp4_pid" ||
    process_is_running "$status_dns2tcp6_pid"
}

chk_iptables_is_started() {
    \iptables  -t mangle -S SSTP_OUTPUT &>/dev/null ||
    \iptables  -t nat    -S SSTP_OUTPUT &>/dev/null ||
    \ip6tables -t mangle -S SSTP_OUTPUT &>/dev/null ||
    \ip6tables -t nat    -S SSTP_OUTPUT &>/dev/null ||
    \ip -4 route show table $ipts_rt_tab 2>/dev/null | \grep -qE '.' ||
    \ip -6 route show table $ipts_rt_tab 2>/dev/null | \grep -qE '.' ||
    \ip -4 rule 2>/dev/null | \grep -qF "fwmark $ipts_rt_mark" ||
    \ip -6 rule 2>/dev/null | \grep -qF "fwmark $ipts_rt_mark"
}

chk_proxyserver_is_started() {
    process_is_running "$status_v2ray_pid"  ||
    process_is_running "$status_ss_pid"
}

chk_base64()   {
    [ -n "$bin_base64_decode" ] && return
    bin_base64_decode=''
    command_is_exists 'base64' || log_fault "command not found: base64"

    \base64 -d       </dev/null &>/dev/null && bin_base64_decode='base64 -d'
    \base64 --decode </dev/null &>/dev/null && bin_base64_decode='base64 --decode'
    [ -n "$bin_base64_decode" ] || log_fault "command args is not support: base64 -d/--decode"
}

chk_iptables_mod()  { iptables $1 -m $2 -h &>/dev/null;      }
chk_kernel_mod()    { \lsmod | \grep -qiE "\b$1\b";  }

is_ipv4_ipts()      { [ "$1" = '-4' ];    }
is_ipv6_ipts()      { [ "$1" = '-6' ];    }
iptables()      {
    is_ipv4_ipts $1 && { "$bin_iptables"  "$@"; return $?; }
    is_ipv6_ipts $1 && { "$bin_ip6tables" "$@"; return $?; }
}

is_global_mode()    { [ "$mode" = 'global' ];   }
is_gfwlist_mode()   { [ "$mode" = 'gfwlist' ];  }
is_chnroute_mode()  { [ "$mode" = 'chnroute' ]; }
is_nonstd_dnsport() { [ "$1" != '53' ];         }

is_ss()        { [ "${1:-$__proxy_schema}" = "ss" ];      }
is_ssr()       { [ "${1:-$__proxy_schema}" = "ssr" ];     }
is_v2ray()     { [ "${1:-$__proxy_schema}" = "vmess" ];   }

get_listen_addr() { is_false "$proxy_local" && \echo '0.0.0.0' || \echo '127.0.0.1'; }

is_enabled_udp()    { is_false "$tcponly";      }
is_need_iproute()   { is_true "$tproxy" || is_enabled_udp; }

is_empty_iptschain()    { iptables $1 -t $2 -S $3 | \grep -qE '^-A'; }

is_ipv4_address()   { \grep -qE "${IPV4_PATTERN}$" <<<"$1";    }
is_ipv6_address()   { \grep -qE "${IPV6_PATTERN}$" <<<"$1";    }
is_ipv4_net()       { \grep -qE "${IPV4_NET_PATTERN}" <<<"$1";    }
is_ipv6_net()       { \grep -qE "${IPV6_NET_PATTERN}" <<<"$1";    }
is_domain_name()    { \grep -qE "${DOMAIN_PATTERN}$" <<<"$1";  }

is_port_using()     { $bin_netstat -an | \grep -F LISTEN | \grep -qF ":$1" &>/dev/null; }

is_variable_array()     { \declare -p $1 2>/dev/null | \grep -qE -- '^declare -a'; }
is_variable_defined()   { \declare -p $1 &>/dev/null;                            }

uniq_array()    {   \tr ' ' '\n' <<< "${1}" | \sort -u | \tr '\n' ' '; }

is_setname_exists() { ! \ipset test $1 1 2>&1 | \grep -qF 'not exist'; }

set_sysctl_option() {
    local option_name="$1" option_value="$2"
    if command_is_exists "sysctl"; then
        \sysctl -w "$option_name=$option_value" >/dev/null
    else
        local option_path="/proc/sys/${option_name//.//}"
        \echo "$option_value" >$option_path
    fi
}

print_proxy_status() {
    is_v2ray && \
        \printf "$(color_yellow $(\jq -rc .outbounds[].streamSettings.wsSettings.headers.host <"$v2ray_config_file"))";
    is_ssr   && \
        \printf "$(color_yellow $(\jq -rc .remarks <"$ssr_config_file"))";
    is_ss   && \
        \printf "$(color_yellow $(\jq -rc .server <"$ssr_config_file"))";
}

resolve_hostname_by_hosts() {
    \awk "!/^#/ && /\s+$1\s*$/{print \$1;exit}" /etc/hosts
}

resolve_hostname_by_dig() {
    local addr_family="$1" hostname="$2"
    local ipaddr=$(resolve_hostname_by_hosts "$hostname")
    if [ "$ipaddr" ]; then
        [ "$addr_family" = '-a' ] && \echo "$ipaddr" && return

        if [ "$addr_family" = '-4' ] && is_ipv4_address "$ipaddr"; then
            \echo "$ipaddr"
            return
        fi
        if [ "$addr_family" = '-6' ] && is_ipv6_address "$ipaddr"; then
            \echo "$ipaddr"
            return
        fi
    fi
    [ "$addr_family" = '-a' ] && { \dig "$hostname" | \grep -Ev '^;|\.$' | \head -n1; return; }

    [ "$addr_family" = '-4' ] && local dns_qtype='A' || local dns_qtype='AAAA'
    \dig +short "$dns_qtype" "$hostname" | \grep -Ev '^;|\.$' | \head -n1
}

resolve_hostname_by_getent() {
    local addr_family="$1" hostname="$2"
    [ "$addr_family" = '-4' ] && local db_name='ahostsv4' || local db_name='ahostsv6'
    \getent "$db_name" "$hostname" | \head -n1 | \awk '{print $1}'
}

resolve_hostname_by_ping() {
    local addr_family="$1" hostname="$2"
    [ "$addr_family" = '-a' ] && { \ping -nq -c1 -t1 -W1 "$hostname" | \sed '1{s/[^(]*(//;s/).*//;q}'; return; }
    [ "$addr_family" = '-4' ] && local ping_cmd="$bin_ping4" || local ping_cmd="$bin_ping6"
    $ping_cmd  -nq -c1 -t1 -W1 "$hostname" | \sed '1{s/[^(]*(//;s/).*//;q}';
}

resolve_hostname() {
    local ipaddr=""
    local retry=${2:-3}
    while [ -z "$ipaddr" -a "$retry" -gt 0 ]; do
        ipaddr=$($func_resolver -a "$1")
        [ -z "$ipaddr" ] && \sleep 1
        let retry=retry-1
    done
    [ -z "$ipaddr" ] && log_fault "resolve hostname error: $1"
    \echo "$ipaddr"
}

resolve_hostname4() {
    local ipaddr=""
    local retry=${2:-3}
    while [ -z "$ipaddr" -a "$retry" -gt 0  ]; do
        ipaddr=$($func_resolver -4 "$1")
        [ -z "$ipaddr" ] && \sleep 1
        let retry=retry-1
    done
    [ -z "$ipaddr" ] && log_fault "resolve ipv4 hostname error: $1"
    \echo "$ipaddr"
}

resolve_hostname6() {
    local ipaddr=""
    local retry=${2:-3}
    while [ -z "$ipaddr" -a "$retry" -gt 0  ]; do
        ipaddr=$($func_resolver -6 "$1")
        [ -z "$ipaddr" ] && \sleep 1
        let retry=retry-1
    done
    [ -z "$ipaddr" ] && log_fault "resolve ipv6 hostname error: $1"
    \echo "$ipaddr"
}

waiting_network() {
    [ -z "$1" ] && return
    is_ipv4_address "$1" && local ping_cmd="$bin_ping4" || local ping_cmd="$bin_ping6"
    until $ping_cmd -nq -c1 -W1 "$1" >/dev/null; do
        \echo "waiting for network available..."
        \sleep 1
    done
}

ipset_family() {
    [ "$1" = '-4' ] && \echo inet || \echo inet6
}

load_pidfile() {
    status_dnsmasq_pid=$(   cut -d: -f1 "$file_dnsserver_pid" | grep -E '^[0-9]+$') && \
    status_chinadns_pid=$(  cut -d: -f2 "$file_dnsserver_pid" | grep -E '^[0-9]+$') && \
    status_dns2tcp4_pid=$(  cut -d: -f3 "$file_dnsserver_pid" | grep -E '^[0-9]+$') && \
    status_dns2tcp6_pid=$(  cut -d: -f4 "$file_dnsserver_pid" | grep -E '^[0-9]+$') && \
    status_v2ray_pid=$(     cut -d: -f5 "$file_dnsserver_pid" | grep -E '^[0-9]+$') && \
    status_ss_pid=$(        cut -d: -f6 "$file_dnsserver_pid" | grep -E '^[0-9]+$') && return 0

    log_fault "load pidfile failed, exit-code: $?"
}

set_default_pid() {
    status_dnsmasq_pid=0
    status_chinadns_pid=0
    status_dns2tcp4_pid=0
    status_dns2tcp6_pid=0
    status_v2ray_pid=0
    status_ss_pid=0
}

update_pidfile() {
    {
        \printf ${status_dnsmasq_pid:-0}:
        \printf ${status_chinadns_pid:-0}:
        \printf ${status_dns2tcp4_pid:-0}:
        \printf ${status_dns2tcp6_pid:-0}:
        \printf ${status_v2ray_pid:-0}:
        \printf ${status_ss_pid:-0}:
    } >"$file_dnsserver_pid"
}

delete_pidfile() {
    \rm -f $file_dnsserver_pid &>/dev/null
}

save_config() {
  local file="$1"
  shift

  local args= opt= key= val=
  local update_vars=

  while [[ -n $1 ]]; do
    opt="$1"
    key="$2"
    val="$3"

    shift;shift;
    [[ "$opt" =~ ^- ]] && shift || { val=$key; key=$opt; opt= ; }

    if \grep -qE "^\s*$key=" "$file"; then
        case "$opt" in
        # save config when value is empty
            -e)   args="${args}s#^\s*$key=\(''\|\"\"\|()\|\s\|$\)#$key=$val #;";;
            -r|*) args="${args}s#^\s*$key=[^\#]*\?\([ \t]*\|[ \t]*\#\)#$key=$val \\1#;";;
        esac
    else
        args="${args}i\\$key=$val;"
    fi

    update_vars="$key=$val;$update_vars";
  done
  [ -z "$args" ] && return 0
  \sed -ie "{
$args
}" "$file"

  eval "$update_vars"
}

readonly OVERRIDE_CONFIG=(mode tproxy tcponly selfonly proxy_tcpport proxy_udpport dns_direct dns_direct6 dns_remote dns_remote6 \
    proxy_uri proxy_startcmd proxy_stopcmd file_dnsserver_pid dnsmasq_bind_port dnsmasq_cache_size dnsmasq_cache_time \
    dnsmasq_query_maxcnt dnsmasq_log_enable dnsmasq_log_file dnsmasq_config_file dnsmasq_gfwlist_file dnsmasq_ignore_file \
    chinadns_bind_port chinadns_timeout chinadns_repeat chinadns_fairmode chinadns_gfwlist_mode chinadns_noip_as_chnip \
    chinadns_verbose chinadns_logfile dns2tcp_bind_port dns2tcp_verbose dns2tcp_logfile ipts_if_lo ipts_rt_tab \
    ipts_rt_mark ipts_set_snat ipts_set_snat6 ipts_reddns_onstop ipts_proxy_dst_port opts_ss_netstat \
    opts_ping_cmd_to_use opts_hostname_resolver opts_ip_for_check_net ipset_privaddr_name ipset_gfwlist_name \
    ipset_chnroute_name ipset_timeout file_gfwlist_txt file_gfwlist_ext file_ignlist_ext file_chnroute_set \
    file_chnroute6_set v2ray_config_file ssr_config_file bin_v2ray bin_ssr bin_ss)

config_check_allow_override() {
     echo "${OVERRIDE_CONFIG[@]}" | grep -wqF "$1"
}

check_iptable_env() {
    if is_true "$ipv4"; then
        [ -z "$bin_iptables" ] && command_is_exists 'iptables' && bin_iptables="$(\which iptables)"
        [ -x "$bin_iptables" ] || log_fault "command not found: iptables";
    fi
    if is_true "$ipv6"; then
        [ -z "$bin_ip6tables" ] && command_is_exists 'ip6tables' && bin_ip6tables="$(\which ip6tables)"
        [ -x "$bin_ip6tables" ] || log_fault "command not found: ip6tables";
    fi

    # check iptables match is support
    for match in set mark multiport addrtype conntrack; do
        is_true "$ipv4" && { chk_iptables_mod -4 ${match} || log_fault "iptables match not found. try 'modprobe xt_${match}.ko'"; }
        is_true "$ipv6" && { chk_iptables_mod -6 ${match} || log_fault "ip6tables match not found. try 'modprobe xt_${match}.ko'"; }
    done

    # check kernel modules exists
    local require_mods=(
        'iptable_nat'
        'iptable_mangle'
        'iptable_raw'

        'xt_nat'
        'xt_multiport'
        'xt_tcpudp'
        'ipt_MASQUERADE'

        "nfnetlink"
        "ip_set"
        "ip_set_hash_net"
        "xt_set"

        'nf_tproxy_core'
        'xt_TPROXY'
        'xt_mark'
        'xt_connmark'
        'xt_addrtype'
        'xt_conntrack'
    )
    for mod in ${require_mods[@]}; do
        chk_kernel_mod ${mod}  || log_fault "kernel module not found. try 'modprobe xt_${mod}.ko'";
    done

    start_ipset
}

check_proxy_env() {
    { [ -n "$__proxy_schema" ] && command_is_exists "base64"; }  || log_fault "command not found: base64"
    { [ -n "$__proxy_schema" ] && command_is_exists "jq"; }      || log_fault "command not found: jq"

    command_is_exists 'mktemp' || log_fault "command not found: mktemp";

    if is_v2ray; then
        [ -z "$bin_v2ray" ] && command_is_exists "v2ray" && bin_v2ray="v2ray"
        [ -z "$bin_v2ray" ] && log_fault "bin_v2ray not configure"
        [ -x "$bin_v2ray" ] || log_fault "bin not found: $bin_v2ray"
    elif is_ss || is_ssr; then
        [ -z "$bin_ssr" ] && {
            command_is_exists "ss-local" && bin_ssr="$(\which ss-local)"
            command_is_exists "ss-redir" && bin_ssr="$(\which ss-redir)"
        }
        [ -z "$bin_ssr" ] && log_fault "bin_ssr not configure";
        [ -x "$bin_ssr" ] || log_fault "bin not found: $bin_ssr";
        [ -z "$bin_ss" ] && bin_ss="$bin_ssr"
    fi
}

check_dnsmasq_env() {
    [ -z "$bin_dnsmasq" ] && command_is_exists "dnsmasq" && bin_dnsmasq="$(\which dnsmasq)"
    [ -z "$bin_dnsmasq" ] && log_fault "bin_dnsmasq not configure"
    [ -x "$bin_dnsmasq" ] || log_fault "bin not found: $bin_dnsmasq"
}

check_env() {
    \command -v 'which' &>/dev/null || log_fault "command not found: which"

    [ -d "$base_dir" ] || log_fault "$base_dir not exists"

    for cmd in ls grep sed awk kill mv rm cat cut touch sort uniq ipset lsmod; do
        command_is_exists $cmd   || log_fault "command not found: $cmd"
    done

    is_need_iproute && { command_is_exists 'ip' || log_fault "command not found: ip"; }
    if ! is_enabled_udp; then
        [ -z "$bin_dns2tcp" ] && command_is_exists 'dns2tcp' && bin_dns2tcp="$(\which dns2tcp)"
        [ -x "$bin_dns2tcp" ] || log_fault "command not found: dns2tcp";
    fi
    if is_chnroute_mode; then
        [ -z "$bin_chinadnsng" ] && command_is_exists 'chinadns-ng' && bin_chinadnsng="$(\which chinadns-ng)"
        [ -x "$bin_chinadnsng" ] || log_fault "command not found: chinadns-ng";
    fi

    if is_true $opts_overwrite_resolv; then
        command_is_exists 'umount' || log_fault "command not found: umount";
        command_is_exists 'mount'  || log_fault "command not found: mount";
        command_is_exists 'mktemp' || log_fault "command not found: mktemp";
        command_is_exists 'chmod'  || log_fault "command not found: chmod";
        command_is_exists 'date'   || log_fault "command not found: date";
    fi

    case "$opts_ss_netstat" in
        auto)
            command_is_exists 'netstat' && bin_netstat='netstat'
            command_is_exists 'ss'      && bin_netstat='ss'
            [ -n "$bin_netstat" ] || log_fault "command not found: ss/netstat"
            ;;
        ss)
            command_is_exists 'ss' && bin_netstat='ss' || log_fault "command not found: ss"
            ;;
        netstat)
            command_is_exists 'netstat' && bin_netstat='netstat' || log_fault "command not found: netstat"
            ;;
        *)
            log_fault "the value of the opts_ss_netstat option is invalid: $opts_ss_netstat"
            ;;
    esac

    case "$opts_ping_cmd_to_use" in
        auto)
            if command_is_exists 'ping' && command_is_exists 'ping6' && ! [ -L "$(\command -v ping6)" ]; then
                bin_ping4='ping'; bin_ping6='ping6'
            elif command_is_exists 'ping'; then
                bin_ping4='ping -4'; bin_ping6='ping -6'
            else
                log_fault "command not found: ping/ping6"
            fi
            ;;
        standalone)
            { command_is_exists 'ping' && command_is_exists 'ping6'; } && { bin_ping4='ping'; bin_ping6='ping6'; } || log_fault "command not found: ping/ping6"
            ;;
        parameter)
            command_is_exists 'ping' && { bin_ping4='ping -4'; bin_ping6='ping -6'; } || log_fault "command not found: ping"
            ;;
        *)
            log_fault "the value of the opts_ping_cmd_to_use option is invalid: $opts_ping_cmd_to_use"
            ;;
    esac

    case "$opts_hostname_resolver" in
        auto)
            if command_is_exists 'dig'; then
                func_resolver='resolve_hostname_by_dig'
            elif command_is_exists 'getent'; then
                func_resolver='resolve_hostname_by_getent'
            elif command_is_exists 'ping'; then
                func_resolver='resolve_hostname_by_ping'
            else
                log_fault "command not found: dig/getent/ping"
            fi
            ;;
        dig)
            command_is_exists 'dig' && func_resolver='resolve_hostname_by_dig' || log_fault "command not found: dig"
            ;;
        getent)
            command_is_exists 'getent' && func_resolver='resolve_hostname_by_getent' || log_fault "command not found: getent"
            ;;
        ping)
            command_is_exists 'ping' && func_resolver='resolve_hostname_by_ping' || log_fault "command not found: ping"
            ;;
        *)
            log_fault "the value of the opts_hostname_resolver option is invalid: $opts_hostname_resolver"
            ;;
    esac
}

check_server_config() {
    [ -z "$proxy_srvport" ] && log_fault "the value of the proxy_srvport option is empty"

    [ "${#proxy_srvaddr4[@]}" -eq 0 -a "${#proxy_srvaddr6[@]}" -eq 0 ] && \
        log_fault "both proxy_srvaddr4 and proxy_srvaddr6 are both empty"
}

check_config() {
    [ -d "$base_dir" ] || log_fault "base directory not exists: $base_dir"
    { is_false "$ipv4" && is_false "$ipv6"; } && log_fault "both ipv4 and ipv6 are disabled, nothing to do"

    file_is_exists "$file_gfwlist_txt"   || log_fault "file not found: $file_gfwlist_txt"
    file_is_exists "$file_gfwlist_ext"   || \touch "$file_gfwlist_ext"
    file_is_exists "$file_ignlist_ext"   || \touch "$file_ignlist_ext"
    file_is_exists "$file_chnroute_set"  || log_fault "file not found: $file_chnroute_set"
    file_is_exists "$file_chnroute6_set" || log_fault "file not found: $file_chnroute6_set"

    if is_v2ray; then
        file_is_exists "$v2ray_config_file" || \touch "$v2ray_config_file"
    elif is_ss || is_ssr; then
        file_is_exists "$ssr_config_file" || \touch "$ssr_config_file"
    fi

    file_is_exists "$file_dnsserver_pid" && load_pidfile || set_default_pid

    __proxy_schema=$(parse_schema "$proxy_uri")

    { ! is_global_mode && ! is_gfwlist_mode && ! is_chnroute_mode; } && log_fault "the value of the mode option is invalid: $mode"

    if [ -n "$__proxy_schema" ]; then
        { ! is_ss && ! is_ssr && ! is_v2ray; } && log_fault "unsupport proxy schema: $__proxy_schema"
    else
        check_server_config
    fi
}

setname_chnroute() {
    is_ipv4_ipts $1 && \echo $ipset_chnroute_name || \echo ${ipset_privaddr_name}6
}

setname_gfwlist() {
    is_ipv4_ipts $1 && \echo $ipset_gfwlist_name || \echo ${ipset_gfwlist_name}6
}

setname_privaddr() {
    is_ipv4_ipts $1 && \echo $ipset_privaddr_name || \echo ${ipset_privaddr_name}6
}

resolve_svraddr() {
    if is_true "$ipv4"; then
        __proxy_svripv4=()
        for svraddr in "${proxy_srvaddr4[@]}"; do
            is_ipv4_address "$svraddr" && local svripv4="$svraddr" || local svripv4=$(resolve_hostname4 "$svraddr")
            __proxy_svripv4+=("$svripv4")
        done
    fi

    if is_true "$ipv6"; then
        __proxy_svripv6=()
        for svraddr in "${proxy_srvaddr6[@]}"; do
            is_ipv6_address "$svraddr" && local svripv6="$svraddr" || local svripv6=$(resolve_hostname6 "$svraddr")
            __proxy_svripv6+=("$svripv6")
        done
    fi
}

do_update_chnlist() {
    local chnlist_file="$1"

    { [ -n "$chnlist_file" ] && file_is_exists "$chnlist_file"; } || log_fault "chnlist file not exists"

    local data;
    if [ -z "$chnlist_file" ]; then
        command_is_exists 'curl' || log_fault "command not found: curl"
        local url='https://raw.github.com/felixonmars/dnsmasq-china-list/master/accelerated-domains.china.conf'
        data="$(\curl -4sSkL "$url" || log_fault "download failed, exit-code: $?")"
    else
        data="$(\cat "$chnlist_file")"
    fi
    \echo "$data" | \awk -F/ '{print $2}' >"$file_gfwlist_txt"
    \echo $(color_yellow "you can restart proxy now")
}

readonly GFWLIST_TXT_SCRIPT_STRING='
{
/^[\s!@\[\/]\+/d;
s/^[|.*]\+//;
s/\*[^.*]\+$//;
s/^[a-z?]\+:[^\w]\+//i;
s/\/.*$//;
/[\*+? ]/d;
/\.$/d;
/^[^\.]\+$/d;
/^\s*$/d;
}'

gfwlist_txt_append_domain_names() {
    \printf "twimg.edgesuite.net\n"
    \printf "blogspot.ae\nblogspot.al\nblogspot.am\nblogspot.ba\nblogspot.be\nblogspot.bg\nblogspot.bj\nblogspot.ca\nblogspot.cat\nblogspot.cf\nblogspot.ch\nblogspot.cl\nblogspot.co.at\nblogspot.co.id\nblogspot.co.il\nblogspot.co.ke\nblogspot.com\nblogspot.com.ar\nblogspot.com.au\nblogspot.com.br\nblogspot.com.by\nblogspot.com.co\nblogspot.com.cy\nblogspot.com.ee\nblogspot.com.eg\nblogspot.com.es\nblogspot.com.mt\nblogspot.com.ng\nblogspot.com.tr\nblogspot.com.uy\nblogspot.co.nz\nblogspot.co.uk\nblogspot.co.za\nblogspot.cv\nblogspot.cz\nblogspot.de\nblogspot.dk\nblogspot.fi\nblogspot.fr\nblogspot.gr\nblogspot.hk\nblogspot.hr\nblogspot.hu\nblogspot.ie\nblogspot.in\nblogspot.is\nblogspot.it\nblogspot.jp\nblogspot.kr\nblogspot.li\nblogspot.lt\nblogspot.lu\nblogspot.md\nblogspot.mk\nblogspot.mr\nblogspot.mx\nblogspot.my\nblogspot.nl\nblogspot.no\nblogspot.pe\nblogspot.pt\nblogspot.qa\nblogspot.re\nblogspot.ro\nblogspot.rs\nblogspot.ru\nblogspot.se\nblogspot.sg\nblogspot.si\nblogspot.sk\nblogspot.sn\nblogspot.td\nblogspot.tw\nblogspot.ug\nblogspot.vn\n"
    \printf "google.ac\ngoogle.ad\ngoogle.ae\ngoogle.al\ngoogle.am\ngoogle.as\ngoogle.at\ngoogle.az\ngoogle.ba\ngoogle.be\ngoogle.bf\ngoogle.bg\ngoogle.bi\ngoogle.bj\ngoogle.bs\ngoogle.bt\ngoogle.by\ngoogle.ca\ngoogle.cat\ngoogle.cc\ngoogle.cd\ngoogle.cf\ngoogle.cg\ngoogle.ch\ngoogle.ci\ngoogle.cl\ngoogle.cm\ngoogle.cn\ngoogle.co.ao\ngoogle.co.bw\ngoogle.co.ck\ngoogle.co.cr\ngoogle.co.id\ngoogle.co.il\ngoogle.co.in\ngoogle.co.jp\ngoogle.co.ke\ngoogle.co.kr\ngoogle.co.ls\ngoogle.com\ngoogle.co.ma\ngoogle.com.af\ngoogle.com.ag\ngoogle.com.ai\ngoogle.com.ar\ngoogle.com.au\ngoogle.com.bd\ngoogle.com.bh\ngoogle.com.bn\ngoogle.com.bo\ngoogle.com.br\ngoogle.com.bz\ngoogle.com.co\ngoogle.com.cu\ngoogle.com.cy\ngoogle.com.do\ngoogle.com.ec\ngoogle.com.eg\ngoogle.com.et\ngoogle.com.fj\ngoogle.com.gh\ngoogle.com.gi\ngoogle.com.gt\ngoogle.com.hk\ngoogle.com.jm\ngoogle.com.kh\ngoogle.com.kw\ngoogle.com.lb\ngoogle.com.lc\ngoogle.com.ly\ngoogle.com.mm\ngoogle.com.mt\ngoogle.com.mx\ngoogle.com.my\ngoogle.com.na\ngoogle.com.nf\ngoogle.com.ng\ngoogle.com.ni\ngoogle.com.np\ngoogle.com.om\ngoogle.com.pa\ngoogle.com.pe\ngoogle.com.pg\ngoogle.com.ph\ngoogle.com.pk\ngoogle.com.pr\ngoogle.com.py\ngoogle.com.qa\ngoogle.com.sa\ngoogle.com.sb\ngoogle.com.sg\ngoogle.com.sl\ngoogle.com.sv\ngoogle.com.tj\ngoogle.com.tr\ngoogle.com.tw\ngoogle.com.ua\ngoogle.com.uy\ngoogle.com.vc\ngoogle.com.vn\ngoogle.co.mz\ngoogle.co.nz\ngoogle.co.th\ngoogle.co.tz\ngoogle.co.ug\ngoogle.co.uk\ngoogle.co.uz\ngoogle.co.ve\ngoogle.co.vi\ngoogle.co.za\ngoogle.co.zm\ngoogle.co.zw\ngoogle.cv\ngoogle.cz\ngoogle.de\ngoogle.dj\ngoogle.dk\ngoogle.dm\ngoogle.dz\ngoogle.ee\ngoogle.es\ngoogle.fi\ngoogle.fm\ngoogle.fr\ngoogle.ga\ngoogle.ge\ngoogle.gf\ngoogle.gg\ngoogle.gl\ngoogle.gm\ngoogle.gp\ngoogle.gr\ngoogle.gy\ngoogle.hn\ngoogle.hr\ngoogle.ht\ngoogle.hu\ngoogle.ie\ngoogle.im\ngoogle.io\ngoogle.iq\ngoogle.is\ngoogle.it\ngoogle.je\ngoogle.jo\ngoogle.kg\ngoogle.ki\ngoogle.kz\ngoogle.la\ngoogle.li\ngoogle.lk\ngoogle.lt\ngoogle.lu\ngoogle.lv\ngoogle.md\ngoogle.me\ngoogle.mg\ngoogle.mk\ngoogle.ml\ngoogle.mn\ngoogle.ms\ngoogle.mu\ngoogle.mv\ngoogle.mw\ngoogle.ne\ngoogle.net\ngoogle.nl\ngoogle.no\ngoogle.nr\ngoogle.nu\ngoogle.org\ngoogle.pl\ngoogle.pn\ngoogle.ps\ngoogle.pt\ngoogle.ro\ngoogle.rs\ngoogle.ru\ngoogle.rw\ngoogle.sc\ngoogle.se\ngoogle.sh\ngoogle.si\ngoogle.sk\ngoogle.sm\ngoogle.sn\ngoogle.so\ngoogle.sr\ngoogle.st\ngoogle.td\ngoogle.tg\ngoogle.tk\ngoogle.tl\ngoogle.tm\ngoogle.tn\ngoogle.to\ngoogle.tt\ngoogle.vg\ngoogle.vu\ngoogle.ws\n"
}

do_update_gfwlist() {
    local gfwlist_file="$1"

    { [ -n "$gfwlist_file" ] && file_is_exists "$gfwlist_file"; } || log_fault "gfwlist file not exists"

    chk_base64

    if [ -z "$gfwlist_file" ]; then
        command_is_exists 'curl'   || log_fault "command not found: curl"
        local url='https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt'
        \curl -4sSkL "$url" | $bin_base64_decode 2>/dev/null | filter_gfwlist >"$file_gfwlist_txt" || \
            log_fault "download failed, exit-code: $?"
    else
        \cat "$gfwlist_file" | $bin_base64_decode 2>/dev/null| filter_gfwlist >"$file_gfwlist_txt"
    fi

    \echo "write to $file_gfwlist_txt" $(color_green "successful")
    \echo $(color_yellow "you can restart dnsmasq now")
}

filter_gfwlist() {
    \cat | { \sed -e "$GFWLIST_TXT_SCRIPT_STRING"; gfwlist_txt_append_domain_names; } | \sort | \uniq
}

do_update_chnroute() {
    local chnroute_file="$1"

    { [ -n "$chnroute_file" ] && file_is_exists "$chnroute_file"; } || log_fault "chnroute file not exists"

    local data;

    if [ -z "$chnroute_file" ]; then
        command_is_exists 'curl' || log_fault "command not found: curl"
        local url='http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest'
        data="$(\curl -4sSkL "$url" || log_fault "download failed, exit-code: $?")"
    else
        data="$(\cat "$chnroute_file")"
    fi
    {
        \echo "create chnroute hash:net family inet"
        \echo "$data" | \grep CN | \grep ipv4 | \awk -F'|' '{printf("%s/%d\n", $4, 32-log($5)/log(2))}'
    } >"$file_chnroute_set"
    {
        \echo "create chnroute6 hash:net family inet6"
        \echo "$data" | \grep CN | \grep ipv6 | \awk -F'|' '{printf("%s/%d\n", $4, $5)}'
    } >"$file_chnroute6_set"
    \echo $(color_yellow "you can restart dnsmasq now")
}

_convert_dnsmasq_domain() {
    local from_file="$1" to_file="$2" dns_server=$3 dns_server6=$4 ipset_prename=$5

    local ipset_name=($({ is_true "$ipv4" && \echo $ipset_prename; }) $({ is_true "$ipv6" && \echo ${ipset_prename}6; }))
    local awk_script="$(
        is_true "$ipv4" && \echo "print \"server = /\"\$1\"/$dns_server\";"
        is_true "$ipv6" && \echo "print \"server = /\"\$1\"/$dns_server6\";"
        \echo "print \"ipset  = /\"\$1\"/$(\echo ${ipset_name[@]} | \sed 's/ /,/')\";"
    )"
    \grep -ioE "$DOMAIN_PATTERN" "$from_file" | \awk "{${awk_script}}" >>"$to_file"

    if is_true "$ipv4"; then
        \grep -oE "$IPV4_NET_PATTERN" "$from_file" | \awk '{print "add '$ipset_prename' "$1}'  | \ipset -R -exist
    elif is_true "$ipv6"; then
        \grep -ioE "$IPV6_NET_PATTERN" "$from_file" | \awk '{print "add '$ipset_prename'6 "$1}' | \ipset -R -exist
    fi
}

start_dnsserver_global() {
    \cat <<EOF >"$dnsmasq_config_file"
$(\echo "$__dnsmasq_common_config")
$(is_true "$ipv4" && \echo "server = $dns_remote")
$(is_true "$ipv6" && \echo "server = $dns_remote6")
conf-file = $dnsmasq_ignore_file
EOF
	>"$dnsmasq_ignore_file"
    _convert_dnsmasq_domain "$file_ignlist_ext" "$dnsmasq_ignore_file" $dns_direct $dns_direct6 privaddr

    status_dnsmasq_pid=$("$bin_dnsmasq" --keep-in-foreground --conf-file=$dnsmasq_config_file & \echo $!)
}

start_dnsserver_gfwlist() {
    \cat <<EOF >"$dnsmasq_config_file"
$(\echo "$__dnsmasq_common_config")
$(is_true "$ipv4" && \echo "server = $dns_direct")
$(is_true "$ipv6" && \echo "server = $dns_direct6")
conf-file = $dnsmasq_gfwlist_file
EOF

    >"$dnsmasq_gfwlist_file"
    _convert_dnsmasq_domain "$file_gfwlist_txt" "$dnsmasq_gfwlist_file" $dns_remote $dns_remote6 gfwlist
    _convert_dnsmasq_domain "$file_gfwlist_ext" "$dnsmasq_gfwlist_file" $dns_remote $dns_remote6 gfwlist

    status_dnsmasq_pid=$("$bin_dnsmasq" --keep-in-foreground --conf-file=$dnsmasq_config_file & \echo $!)
}

start_dnsserver_chnroute() {
    local chinadns_args="-b 127.0.0.1 -l $chinadns_bind_port -o $chinadns_timeout -p $chinadns_repeat"
    is_true "$chinadns_noip_as_chnip" && chinadns_args+=" -n"
    is_true "$chinadns_gfwlist_mode" && chinadns_args+=" -g-"
    is_true "$chinadns_fairmode" && chinadns_args+=" -f"
    is_true "$chinadns_verbose" && chinadns_args+=" -v"
    if is_true "$ipv4" && is_true "$ipv6"; then
        chinadns_args+=" -c $dns_direct,$dns_direct6"
        chinadns_args+=" -t $dns_remote,$dns_remote6"
    elif is_true "$ipv4"; then
        chinadns_args+=" -c $dns_direct"
        chinadns_args+=" -t $dns_remote"
    else
        chinadns_args+=" -c $dns_direct6"
        chinadns_args+=" -t $dns_remote6"
    fi

    is_true "$ipv4" && create_ipset_chnroute -4
    is_true "$ipv6" && create_ipset_chnroute -6

    is_true "$ipv4" && \grep -E "$IPV4_NET_PATTERN" "$file_chnroute_set" | awk '{print "add chnroute "$1}'   | \ipset -R -exist
    is_true "$ipv6" && \grep -E "$IPV6_NET_PATTERN" "$file_chnroute6_set" | awk '{print "add chnroute6 "$1}' | \ipset -R -exist

    is_true "$ipv4" && for addr in "${chinadns_privaddr4[@]}"; do \echo "add chnroute $addr";  done | \ipset -R -exist
    is_true "$ipv6" && for addr in "${chinadns_privaddr6[@]}"; do \echo "add chnroute6 $addr"; done | \ipset -R -exist

    if is_true "$chinadns_gfwlist_mode"; then
        local gfwlist_domain_string=$( {
            \grep -ioE "$DOMAIN_PATTERN" $file_gfwlist_txt $file_gfwlist_ext;
            \grep -oE "$IPV4_NET_PATTERN" $file_gfwlist_txt $file_gfwlist_ext;
            \grep -ioE "$IPV6_NET_PATTERN" $file_gfwlist_txt $file_gfwlist_ext;
         })
        status_chinadns_pid=$("$bin_chinadnsng" $chinadns_args <<<"$gfwlist_domain_string" &>>$chinadns_logfile & \echo $!)
    else
        status_chinadns_pid=$("$bin_chinadnsng" $chinadns_args </dev/null &>>$chinadns_logfile & \echo $!)
    fi

    \cat <<EOF >"$dnsmasq_config_file"
$(\echo "$__dnsmasq_common_config")
server = 127.0.0.1#$chinadns_bind_port
conf-file = ${dnsmasq_ignore_file}
EOF

    >"$dnsmasq_ignore_file"
    _convert_dnsmasq_domain "$file_ignlist_ext" "$dnsmasq_ignore_file" $dns_direct $dns_direct6 privaddr

    status_dnsmasq_pid=$("$bin_dnsmasq" --keep-in-foreground --conf-file=$dnsmasq_config_file & \echo $!)
}

start_dnsmasq_daemon() {
    check_server_config

    local dnsmasq_append_config=("${dnsmasq_conf_string[@]}")
    if is_true "$ipv4"; then
        for ((i = 0; i < ${#proxy_srvaddr4[@]}; ++i)); do
            local server_host="${proxy_srvaddr4[i]}"
            local server_addr="${__proxy_svripv4[i]}"
            if is_domain_name "$server_host"; then
                dnsmasq_append_config+=("address = /$server_host/$server_addr")
            fi
        done
    fi
    if is_true "$ipv6"; then
        for ((i = 0; i < ${#proxy_srvaddr6[@]}; ++i)); do
            local server_host="${proxy_srvaddr6[i]}"
            local server_addr="${__proxy_svripv6[i]}"
            if is_domain_name "$server_host"; then
                dnsmasq_append_config+=("address = /$server_host/$server_addr")
            fi
        done
    fi

    __dnsmasq_common_config=$(\cat <<EOF
$(is_true "$dnsmasq_log_enable" && \echo 'log-queries')
log-facility = $dnsmasq_log_file
log-async = 20
domain-needed
cache-size = $dnsmasq_cache_size
$("$bin_dnsmasq" --help | \grep -qF min-cache-ttl && \echo "min-cache-ttl = $dnsmasq_cache_time")
no-negcache
no-resolv
port = $dnsmasq_bind_port
dns-forward-max = $dnsmasq_query_maxcnt
$(for append_config in "${dnsmasq_append_config[@]}"; do \echo "$append_config"; done)
$(for conf_dir_arg in "${dnsmasq_conf_dir[@]}"; do \echo "conf-dir = $conf_dir_arg"; done)
$(for conf_file_arg in "${dnsmasq_conf_file[@]}"; do \echo "conf-file = $conf_file_arg"; done)
EOF
)

    local original_dns_remote="$dns_remote"
    local original_dns_remote6="$dns_remote6"
    if ! is_enabled_udp; then
        dns_remote="127.0.0.1#$dns2tcp_bind_port"
        dns_remote6="::1#$dns2tcp_bind_port"
    fi

    start_ipset

    if is_global_mode; then
        start_dnsserver_global
    elif is_gfwlist_mode; then
        start_dnsserver_gfwlist
    elif is_chnroute_mode; then
        start_dnsserver_chnroute
    fi

    if ! is_enabled_udp; then
        local dns2tcp_listen_addr4="$dns_remote"
        local dns2tcp_listen_addr6="$dns_remote6"
        local dns2tcp_remote_addr4="$original_dns_remote"
        local dns2tcp_remote_addr6="$original_dns_remote6"
        dns_remote="$original_dns_remote"
        dns_remote6="$original_dns_remote6"
        if is_true "$ipv4"; then
            local dns2tcp_args="-L $dns2tcp_listen_addr4 -R $dns2tcp_remote_addr4"
            is_true "$dns2tcp_verbose" && dns2tcp_args+=" -v"
            status_dns2tcp4_pid=$("$bin_dns2tcp" $dns2tcp_args </dev/null &>>$dns2tcp_logfile & \echo $!)
        fi
        if is_true "$ipv6"; then
            local dns2tcp_args="-L $dns2tcp_listen_addr6 -R $dns2tcp_remote_addr6"
            is_true "$dns2tcp_verbose" && dns2tcp_args+=" -v"
            status_dns2tcp6_pid=$("$bin_dns2tcp" $dns2tcp_args </dev/null &>>$dns2tcp_logfile & \echo $!)
        fi
    fi

    update_pidfile
}

stop_dnsserver() {
    [ '0' -lt "$status_dnsmasq_pid" ]    && kill -9 $status_dnsmasq_pid  &>/dev/null
    [ '0' -lt "$status_chinadns_pid" ]   && kill -9 $status_chinadns_pid &>/dev/null
    [ '0' -lt "$status_dns2tcp4_pid" ]   && kill -9 $status_dns2tcp4_pid &>/dev/null
    [ '0' -lt "$status_dns2tcp6_pid" ]   && kill -9 $status_dns2tcp6_pid &>/dev/null

    stop_proxyserver
    delete_pidfile
}

#  clears cache and then
#  re-loads /etc/hosts and /etc/ethers and any file given by
#  --dhcp-hostsfile, --dhcp-optsfile or --addn-hosts
_flush_dnscache() {
    local SIGNAL=${1:-SIGHUP}
    kill -$SIGNAL "$status_dnsmasq_pid"
}

modify_resolvconf() {
    [ -z "$opts_overwrite_resolv" ] && return
    if is_false "$opts_overwrite_resolv"; then
        while \umount /etc/resolv.conf &>/dev/null; do true; done
        local temp_resolv_conf=$(\mktemp)
        \chmod 0644 $temp_resolv_conf
        \mount -o bind $temp_resolv_conf /etc/resolv.conf
        \rm -f $temp_resolv_conf
    fi
    \echo "# Generated by ss-tproxy at $(\date '+%F %T')" >/etc/resolv.conf
    is_true "$ipv4" && \echo "nameserver 127.0.0.1" >>/etc/resolv.conf
    is_true "$ipv6" && \echo "nameserver ::1" >>/etc/resolv.conf
}

restore_resolvconf() {
    [ -z "$opts_overwrite_resolv" ] && return
    if is_false "$opts_overwrite_resolv"; then
        while \umount /etc/resolv.conf &>/dev/null; do true; done
    else
        \echo "# Generated by ss-tproxy at $(\date '+%F %T')" >/etc/resolv.conf
        is_true "$ipv4" && \echo "nameserver $dns_direct" >>/etc/resolv.conf
        is_true "$ipv6" && \echo "nameserver $dns_direct6" >>/etc/resolv.conf
    fi
}

trigger_proxy_startcmd() {
    \eval "$proxy_startcmd" || log_fault "failed to start local proxy process, exit-code: $?"
}

trigger_proxy_stopcmd() {
    \eval "$proxy_stopcmd" &>/dev/null
}

enable_ipforward() {
    is_true "$ipv4" && set_sysctl_option 'net.ipv4.ip_forward' 1
    is_true "$ipv6" && set_sysctl_option 'net.ipv6.conf.all.forwarding' 1
}

disable_icmpredir() {
    for dir in $(\ls /proc/sys/net/ipv4/conf); do
        set_sysctl_option "net.ipv4.conf.$dir.send_redirects" 0
    done
}

delete_ipset_gfwlist() {
    flush_ipset_gfwlist

    \ipset -X gfwlist  &>/dev/null
    \ipset -X gfwlist6 &>/dev/null
}

flush_ipset_gfwlist() {
    \ipset -F gfwlist  &>/dev/null
    \ipset -F gfwlist6 &>/dev/null
}

delete_ipset_chnroute() {
    flush_ipset_chnroute

    \ipset -X privaddr  &>/dev/null
    \ipset -X privaddr6 &>/dev/null
    \ipset -X chnroute  &>/dev/null
    \ipset -X chnroute6 &>/dev/null
}

flush_ipset_chnroute() {
    \ipset -F privaddr  &>/dev/null
    \ipset -F privaddr6 &>/dev/null
    \ipset -F chnroute  &>/dev/null
    \ipset -F chnroute6 &>/dev/null
}

do_delete_ipset_gfwlist() {
    chk_dnsserver_is_started && log_fault "dnsmasq is running, can not delete"
    chk_iptables_is_started && log_fault "iptables rule is using, can not delete"
    delete_ipset_gfwlist
}

delete_iproute2() {
    \ip -4 rule  del   table $ipts_rt_tab &>/dev/null
    \ip -4 route flush table $ipts_rt_tab &>/dev/null

    \ip -6 rule  del   table $ipts_rt_tab &>/dev/null
    \ip -6 route flush table $ipts_rt_tab &>/dev/null
}

delete_iptables_mangle() {
    iptables $1 -t mangle -D PREROUTING  -j SSTP_PREROUTING  &>/dev/null
    iptables $1 -t mangle -D OUTPUT      -j SSTP_OUTPUT      &>/dev/null

    iptables $1 -t mangle -F SSTP_PREROUTING  &>/dev/null
    iptables $1 -t mangle -F SSTP_OUTPUT      &>/dev/null
    iptables $1 -t mangle -F SSTP_RULE        &>/dev/null

    iptables $1 -t mangle -X SSTP_PREROUTING  &>/dev/null
    iptables $1 -t mangle -X SSTP_OUTPUT      &>/dev/null
    iptables $1 -t mangle -X SSTP_RULE        &>/dev/null
}

delete_iptables_nat() {
    iptables $1 -t nat -D PREROUTING  -j SSTP_PREROUTING  &>/dev/null
    iptables $1 -t nat -D POSTROUTING -j SSTP_POSTROUTING &>/dev/null
    iptables $1 -t nat -D OUTPUT      -j SSTP_OUTPUT      &>/dev/null

    iptables $1 -t nat -F SSTP_PREROUTING  &>/dev/null
    iptables $1 -t nat -F SSTP_POSTROUTING &>/dev/null
    iptables $1 -t nat -F SSTP_OUTPUT      &>/dev/null
    iptables $1 -t nat -F SSTP_RULE        &>/dev/null

    iptables $1 -t nat -X SSTP_PREROUTING  &>/dev/null
    iptables $1 -t nat -X SSTP_POSTROUTING &>/dev/null
    iptables $1 -t nat -X SSTP_OUTPUT      &>/dev/null
    iptables $1 -t nat -X SSTP_RULE        &>/dev/null
}

_show_iptables() {
    \echo "$(color_green "==> iptables-mangle <==")"
    iptables $1 -t mangle -nvL --line-numbers | \sed -n '{
#/^Chain PREROUTING/,/^$/p;
#/^Chain OUTPUT/,/^$/p;
/^Chain SSTP_PREROUTING/,/^$/p;
/^Chain SSTP_OUTPUT/,/^$/p;
/^Chain SSTP_RULE/,/^$/p;
}'
    \echo
    \echo "$(color_green "==> iptables-nat <==")"
    iptables $1 -t nat -nvL --line-numbers | \sed -n '{
#/^Chain PREROUTING/,/^$/p;
#/^Chain POSTROUTING/,/^$/p;
#/^Chain OUTPUT/,/^$/p;
/^Chain SSTP_PREROUTING/,/^$/p;
/^Chain SSTP_POSTROUTING/,/^$/p;
/^Chain SSTP_OUTPUT/,/^$/p;
/^Chain SSTP_RULE/,/^$/p;
}'
}

print_iptables_blance_status() {
    iptables $1 -t nat -A SSTP_RULE -p tcp -m set --match-set $gfwlist_setname dst -m multiport --dports $ipts_proxy_dst_port --syn -j REDIRECT --to-ports $proxy_tcpport}
}

do_show_iptables() {
    is_true "$ipv4" && _show_iptables -4
    { is_true "$ipv4" && is_true "$ipv6"; } && \echo
    is_true "$ipv6" && _show_iptables -6
}

create_dnsredir() {
    is_false "$ipts_reddns_onstop" && return

    local direct_dns_ip
    is_ipv4_ipts $1 && direct_dns_ip="$dns_direct" || direct_dns_ip="$dns_direct6"

    iptables $1 -t nat -N SSTP_PREROUTING  &>/dev/null
    iptables $1 -t nat -N SSTP_POSTROUTING &>/dev/null
    iptables $1 -t nat -A SSTP_PREROUTING  -m addrtype ! --src-type LOCAL --dst-type LOCAL -p udp --dport 53 -j DNAT --to-destination $direct_dns_ip
    iptables $1 -t nat -A SSTP_POSTROUTING -m addrtype ! --src-type LOCAL -p udp -d $direct_dns_ip --dport 53 -j MASQUERADE
}

create_snatrule() {
    local set_snat_rule='false'
    { is_ipv4_ipts $1 && is_true "$ipts_set_snat";  } && set_snat_rule='true'
    { is_ipv6_ipts $1 && is_true "$ipts_set_snat6"; } && set_snat_rule='true'
    is_false "$set_snat_rule" && return

    iptables $1 -t nat -N SSTP_POSTROUTING &>/dev/null
    iptables $1 -t nat -A SSTP_POSTROUTING -m addrtype ! --src-type LOCAL -m conntrack --ctstate SNAT,DNAT   -j RETURN
    iptables $1 -t nat -A SSTP_POSTROUTING -m addrtype ! --src-type LOCAL -p tcp --syn                       -j MASQUERADE
    iptables $1 -t nat -A SSTP_POSTROUTING -m addrtype ! --src-type LOCAL -p udp -m conntrack --ctstate NEW  -j MASQUERADE
    iptables $1 -t nat -A SSTP_POSTROUTING -m addrtype ! --src-type LOCAL -p icmp -m conntrack --ctstate NEW -j MASQUERADE
}

create_iptschain() {
    iptables $1 -t nat -nL SSTP_PREROUTING  &>/dev/null && iptables $1 -t nat -A PREROUTING  -j SSTP_PREROUTING
    iptables $1 -t nat -nL SSTP_POSTROUTING &>/dev/null && iptables $1 -t nat -A POSTROUTING -j SSTP_POSTROUTING
}

create_postrule() {
    chk_dnsserver_is_started && return
    { is_false "$ipts_reddns_onstop" && is_false "$ipts_set_snat" && is_false "$ipts_set_snat6"; } && return
    is_true "$ipv4" && { create_dnsredir -4; create_snatrule -4; create_iptschain -4;  }
    is_true "$ipv6" && { create_dnsredir -6; create_snatrule -6; create_iptschain -6; }
}

do_stop_iptables() {
    delete_iptables_mangle -4
    delete_iptables_mangle -6
    delete_iptables_nat -4
    delete_iptables_nat -6

    resolve_svraddr
    for addr in ${__proxy_svripv4[@]}; do iptables -4 -t nat -D OUTPUT -d $addr &>/dev/null; done
    for addr in ${__proxy_svripv6[@]}; do iptables -6 -t nat -D OUTPUT -d $addr &>/dev/null; done

}

_delete_unused_iptchains() {
    if is_empty_iptschain $1 mangle SSTP_PREROUTING; then
        iptables $1 -t mangle -D PREROUTING -j SSTP_PREROUTING
        iptables $1 -t mangle -X SSTP_PREROUTING
    fi
    if is_empty_iptschain $1 mangle SSTP_OUTPUT; then
        iptables $1 -t mangle -D OUTPUT -j SSTP_OUTPUT
        iptables $1 -t mangle -X SSTP_OUTPUT
    fi
    if is_empty_iptschain $1 nat SSTP_PREROUTING; then
        iptables $1 -t nat -D PREROUTING -j SSTP_PREROUTING
        iptables $1 -t nat -X SSTP_PREROUTING
    fi
    if is_empty_iptschain $1 nat SSTP_OUTPUT; then
        iptables $1 -t nat -D OUTPUT -j SSTP_OUTPUT
        iptables $1 -t nat -X SSTP_OUTPUT
    fi
    if is_empty_iptschain $1 nat SSTP_POSTROUTING; then
        iptables $1 -t nat -D POSTROUTING -j SSTP_POSTROUTING
        iptables $1 -t nat -X SSTP_POSTROUTING
    fi
}

delete_unused_iptchains() {
    _delete_unused_iptchains -4
    _delete_unused_iptchains -6
}

start_iptables_pre_rules() {
    iptables $1 -t mangle -N SSTP_PREROUTING
    iptables $1 -t mangle -N SSTP_OUTPUT
    iptables $1 -t nat    -N SSTP_PREROUTING
    iptables $1 -t nat    -N SSTP_OUTPUT
    iptables $1 -t nat    -N SSTP_POSTROUTING

    if is_need_iproute; then
        local iproute2_family="$1"
        \ip $iproute2_family route add local default dev $ipts_if_lo table $ipts_rt_tab
        \ip $iproute2_family rule  add fwmark $ipts_rt_mark          table $ipts_rt_tab
    fi
}

start_iptables_post_rules() {
    iptables $1 -t mangle -A PREROUTING  -j SSTP_PREROUTING
    iptables $1 -t mangle -A OUTPUT      -j SSTP_OUTPUT
    iptables $1 -t nat    -A PREROUTING  -j SSTP_PREROUTING
    iptables $1 -t nat    -A OUTPUT      -j SSTP_OUTPUT
    iptables $1 -t nat    -A POSTROUTING -j SSTP_POSTROUTING
}

start_iptables_tproxy_mode() {
    local loopback_addr
    is_ipv4_ipts "$1" && loopback_addr="127.0.0.1" || loopback_addr="::1"

    local svr_ip_array=()
    is_ipv4_ipts "$1" && svr_ip_array=("${__proxy_svripv4[@]}") || svr_ip_array=("${__proxy_svripv6[@]}")

    local direct_dns_ip
    is_ipv4_ipts "$1" && direct_dns_ip="$dns_direct" || direct_dns_ip="$dns_direct6"

    local remote_dns_ip remote_dns_port
    is_ipv4_ipts "$1" && remote_dns_ip="${dns_remote%%#*}" || remote_dns_ip="${dns_remote6%%#*}"
    is_ipv4_ipts "$1" && remote_dns_port="${dns_remote##*#}" || remote_dns_port="${dns_remote6##*#}"

    local gfwlist_setname=$(setname_gfwlist $1)
    local chnroute_setname=$(setname_chnroute $1)
    local privaddr_setname=$(setname_privaddr $1)

    ######################### SSTP_RULE (tcp and udp) #########################

    iptables $1 -t mangle -N SSTP_RULE

    iptables $1 -t mangle -A SSTP_RULE -j CONNMARK --restore-mark
    iptables $1 -t mangle -A SSTP_RULE -m mark --mark $ipts_rt_mark -j RETURN

    for svr_ip in "${svr_ip_array[@]}"; do
        iptables $1 -t mangle -A SSTP_RULE -p tcp -d $svr_ip -m multiport --dports $proxy_srvport -j RETURN
        is_enabled_udp && iptables $1 -t mangle -A SSTP_RULE -p udp -d $svr_ip -m multiport --dports $proxy_srvport -j RETURN
        iptables $1 -t nat -A OUTPUT -d $svr_ip
    done

    if is_enabled_udp; then
        iptables $1 -t mangle -A SSTP_RULE -p udp -d $direct_dns_ip --dport 53               -j RETURN
        iptables $1 -t mangle -A SSTP_RULE -p udp -d $remote_dns_ip --dport $remote_dns_port -j MARK --set-mark $ipts_rt_mark
        iptables $1 -t mangle -A SSTP_RULE -p udp -d $remote_dns_ip --dport $remote_dns_port -j RETURN
    else
        iptables $1 -t mangle -A SSTP_RULE -p tcp -d $remote_dns_ip --dport $remote_dns_port -j MARK --set-mark $ipts_rt_mark
        iptables $1 -t mangle -A SSTP_RULE -p tcp -d $remote_dns_ip --dport $remote_dns_port -j RETURN
    fi

    if is_gfwlist_mode; then
        iptables $1 -t mangle -A SSTP_RULE -p tcp -m set --match-set $gfwlist_setname dst -m multiport --dports $ipts_proxy_dst_port --syn -j MARK --set-mark $ipts_rt_mark
        is_enabled_udp && iptables $1 -t mangle -A SSTP_RULE -p udp -m set --match-set $gfwlist_setname dst -m multiport --dports $ipts_proxy_dst_port -m conntrack --ctstate NEW -j MARK --set-mark $ipts_rt_mark
    elif is_global_mode; then
        iptables $1 -t mangle -A SSTP_RULE -m set --match-set $privaddr_setname dst -j RETURN
        iptables $1 -t mangle -A SSTP_RULE -p tcp -m multiport --dports $ipts_proxy_dst_port --syn -j MARK --set-mark $ipts_rt_mark
        is_enabled_udp && iptables $1 -t mangle -A SSTP_RULE -p udp -m multiport --dports $ipts_proxy_dst_port -m conntrack --ctstate NEW -j MARK --set-mark $ipts_rt_mark
    elif is_chnroute_mode; then
        iptables $1 -t mangle -A SSTP_RULE -m set --match-set $privaddr_setname dst -j RETURN
        iptables $1 -t mangle -A SSTP_RULE -m set --match-set $chnroute_setname dst -j RETURN
        iptables $1 -t mangle -A SSTP_RULE -p tcp -m multiport --dports $ipts_proxy_dst_port --syn -j MARK --set-mark $ipts_rt_mark
        is_enabled_udp && iptables $1 -t mangle -A SSTP_RULE -p udp -m multiport --dports $ipts_proxy_dst_port -m conntrack --ctstate NEW -j MARK --set-mark $ipts_rt_mark
    fi

    iptables $1 -t mangle -A SSTP_RULE -j CONNMARK --save-mark

    ######################### SSTP_OUTPUT/SSTP_PREROUTING #########################

    if is_nonstd_dnsport "$dnsmasq_bind_port"; then
        iptables $1 -t nat -A SSTP_OUTPUT -p udp -d $loopback_addr --dport 53 -j REDIRECT --to-ports $dnsmasq_bind_port
    fi

    iptables $1 -t mangle -A SSTP_OUTPUT -m addrtype --src-type LOCAL ! --dst-type LOCAL -p tcp -j SSTP_RULE
    is_enabled_udp && iptables $1 -t mangle -A SSTP_OUTPUT -m addrtype --src-type LOCAL ! --dst-type LOCAL -p udp -j SSTP_RULE

    iptables $1 -t mangle -A SSTP_PREROUTING -i $ipts_if_lo -m mark ! --mark $ipts_rt_mark -j RETURN

    if is_false "$selfonly"; then
        if is_nonstd_dnsport "$dnsmasq_bind_port"; then
            is_enabled_udp && iptables $1 -t mangle -A SSTP_PREROUTING -m addrtype ! --src-type LOCAL --dst-type LOCAL -p udp --dport 53 -j RETURN
            iptables $1 -t nat -A SSTP_PREROUTING -m addrtype ! --src-type LOCAL --dst-type LOCAL -p udp --dport 53 -j REDIRECT --to-ports $dnsmasq_bind_port
        fi

        iptables $1 -t mangle -A SSTP_PREROUTING -m addrtype ! --src-type LOCAL ! --dst-type LOCAL -p tcp -j SSTP_RULE
        is_enabled_udp && iptables $1 -t mangle -A SSTP_PREROUTING -m addrtype ! --src-type LOCAL ! --dst-type LOCAL -p udp -j SSTP_RULE
    fi

    iptables $1 -t mangle -A SSTP_PREROUTING -p tcp -m mark --mark $ipts_rt_mark -j TPROXY --on-ip $loopback_addr --on-port $proxy_tcpport
    is_enabled_udp && iptables $1 -t mangle -A SSTP_PREROUTING -p udp -m mark --mark $ipts_rt_mark -j TPROXY --on-ip $loopback_addr --on-port $proxy_udpport

    create_snatrule $1
}

start_iptables_redirect_mode() {
    local loopback_addr
    is_ipv4_ipts $1 && loopback_addr="127.0.0.1" || loopback_addr="::1"

    local gfwlist_setfamily
    is_ipv4_ipts $1 && gfwlist_setfamily="inet" || gfwlist_setfamily="inet6"

    local svr_ip_array=()
    is_ipv4_ipts $1 && svr_ip_array=("${__proxy_svripv4[@]}") || svr_ip_array=("${__proxy_svripv6[@]}")

    local direct_dns_ip
    is_ipv4_ipts $1 && direct_dns_ip="$dns_direct" || direct_dns_ip="$dns_direct6"

    local remote_dns_ip remote_dns_port
    is_ipv4_ipts $1 && remote_dns_ip="${dns_remote%%#*}" || remote_dns_ip="${dns_remote6%%#*}"
    is_ipv4_ipts $1 && remote_dns_port="${dns_remote##*#}" || remote_dns_port="${dns_remote6##*#}"

    local gfwlist_setname=$(setname_gfwlist $1)
    local chnroute_setname=$(setname_chnroute $1)
    local privaddr_setname=$(setname_privaddr $1)

    ######################### SSTP_RULE (for tcp) #########################

    iptables $1 -t nat -N SSTP_RULE

    for svr_ip in "${svr_ip_array[@]}"; do
        iptables $1 -t nat -A SSTP_RULE -p tcp -d $svr_ip -m multiport --dports $proxy_srvport -j RETURN
        iptables $1 -t nat -A OUTPUT -d $svr_ip
    done

    if ! is_enabled_udp; then
        iptables $1 -t nat -A SSTP_RULE -p tcp -d $remote_dns_ip --dport $remote_dns_port --syn -j REDIRECT --to-ports $proxy_tcpport
    fi

    if is_gfwlist_mode; then
        iptables $1 -t nat -A SSTP_RULE -p tcp -m set --match-set $gfwlist_setname dst -m multiport --dports $ipts_proxy_dst_port --syn -j REDIRECT --to-ports $proxy_tcpport
    elif is_global_mode; then
        iptables $1 -t nat -A SSTP_RULE -m set --match-set $privaddr_setname dst -j RETURN
        iptables $1 -t nat -A SSTP_RULE -p tcp -m multiport --dports $ipts_proxy_dst_port --syn -j REDIRECT --to-ports $proxy_tcpport
    elif is_chnroute_mode; then
        iptables $1 -t nat -A SSTP_RULE -m set --match-set $privaddr_setname dst -j RETURN
        iptables $1 -t nat -A SSTP_RULE -m set --match-set $chnroute_setname dst -j RETURN
        iptables $1 -t nat -A SSTP_RULE -p tcp -m multiport --dports $ipts_proxy_dst_port --syn -j REDIRECT --to-ports $proxy_tcpport
    fi

    ######################### SSTP_RULE (for udp) #########################

    if is_enabled_udp; then
        iptables $1 -t mangle -N SSTP_RULE

        iptables $1 -t mangle -A SSTP_RULE -j CONNMARK --restore-mark
        iptables $1 -t mangle -A SSTP_RULE -m mark --mark $ipts_rt_mark -j RETURN

        for svr_ip in "${svr_ip_array[@]}"; do
            iptables $1 -t mangle -A SSTP_RULE -p udp -d $svr_ip -m multiport --dports $proxy_srvport -j RETURN
        done

        iptables $1 -t mangle -A SSTP_RULE -p udp -d $direct_dns_ip --dport 53               -j RETURN
        iptables $1 -t mangle -A SSTP_RULE -p udp -d $remote_dns_ip --dport $remote_dns_port -j MARK --set-mark $ipts_rt_mark
        iptables $1 -t mangle -A SSTP_RULE -p udp -d $remote_dns_ip --dport $remote_dns_port -j RETURN

        if is_gfwlist_mode; then
            iptables $1 -t mangle -A SSTP_RULE -p udp -m set --match-set $gfwlist_setname dst -m multiport --dports $ipts_proxy_dst_port -m conntrack --ctstate NEW -j MARK --set-mark $ipts_rt_mark
        elif is_global_mode; then
            iptables $1 -t mangle -A SSTP_RULE -m set --match-set $privaddr_setname dst -j RETURN
            iptables $1 -t mangle -A SSTP_RULE -p udp -m multiport --dports $ipts_proxy_dst_port -m conntrack --ctstate NEW -j MARK --set-mark $ipts_rt_mark
        elif is_chnroute_mode; then
            iptables $1 -t mangle -A SSTP_RULE -m set --match-set $privaddr_setname dst -j RETURN
            iptables $1 -t mangle -A SSTP_RULE -m set --match-set $chnroute_setname dst -j RETURN
            iptables $1 -t mangle -A SSTP_RULE -p udp -m multiport --dports $ipts_proxy_dst_port -m conntrack --ctstate NEW -j MARK --set-mark $ipts_rt_mark
        fi

        iptables $1 -t mangle -A SSTP_RULE -j CONNMARK --save-mark
    fi

    ######################### SSTP_OUTPUT/SSTP_PREROUTING #########################

    if is_nonstd_dnsport "$dnsmasq_bind_port"; then
        iptables $1 -t nat -A SSTP_OUTPUT -p udp -d $loopback_addr --dport 53 -j REDIRECT --to-ports $dnsmasq_bind_port
    fi

    iptables $1 -t nat -A SSTP_OUTPUT -m addrtype --src-type LOCAL ! --dst-type LOCAL -p tcp -j SSTP_RULE
    is_enabled_udp && iptables $1 -t mangle -A SSTP_OUTPUT -m addrtype --src-type LOCAL ! --dst-type LOCAL -p udp -j SSTP_RULE

    is_enabled_udp && iptables $1 -t mangle -A SSTP_PREROUTING -i $ipts_if_lo -m mark ! --mark $ipts_rt_mark -j RETURN

    if is_false "$selfonly"; then
        if is_nonstd_dnsport "$dnsmasq_bind_port"; then
            is_enabled_udp && iptables $1 -t mangle -A SSTP_PREROUTING -m addrtype ! --src-type LOCAL --dst-type LOCAL -p udp --dport 53 -j RETURN
            iptables $1 -t nat -A SSTP_PREROUTING -m addrtype ! --src-type LOCAL --dst-type LOCAL -p udp --dport 53 -j REDIRECT --to-ports $dnsmasq_bind_port
        fi

        iptables $1 -t nat -A SSTP_PREROUTING -m addrtype ! --src-type LOCAL ! --dst-type LOCAL -p tcp -j SSTP_RULE
        is_enabled_udp && iptables $1 -t mangle -A SSTP_PREROUTING -m addrtype ! --src-type LOCAL ! --dst-type LOCAL -p udp -j SSTP_RULE
    fi

    is_enabled_udp && iptables $1 -t mangle -A SSTP_PREROUTING -p udp -m mark --mark $ipts_rt_mark -j TPROXY --on-ip $loopback_addr --on-port $proxy_udpport

    create_snatrule $1
}

start_iptables() {
    check_iptable_env
    check_server_config
    resolve_svraddr

    is_true "$ipv4" && start_iptables_pre_rules -4
    is_true "$ipv6" && start_iptables_pre_rules -6

    if is_true "$tproxy"; then
        is_true "$ipv4" && start_iptables_tproxy_mode -4
        is_true "$ipv6" && start_iptables_tproxy_mode -6
    else
        is_true "$ipv4" && start_iptables_redirect_mode -4
        is_true "$ipv6" && start_iptables_redirect_mode -6
    fi

    is_true "$ipv4" && start_iptables_post_rules -4
    is_true "$ipv6" && start_iptables_post_rules -6
}

create_ipset_chnroute() {
    local ipset_setfamily=$(ipset_family $1)
    local chnroute_setname=$(setname_chnroute $1)
    is_setname_exists "$chnroute_setname" || \
    \ipset -N -exist "$chnroute_setname" hash:net family "$ipset_setfamily" \
        $({ [ "$ipset_timeout" -gt '0' ] && \echo timeout "$ipset_timeout"; })
}

create_ipset_gfwlist() {
    local ipset_setfamily=$(ipset_family $1)
    local gfwlist_setname=$(setname_gfwlist $1)
    is_setname_exists "$gfwlist_setname" || \
    \ipset -N -exist "$gfwlist_setname" hash:net family "$ipset_setfamily" \
        $({ [ "$ipset_timeout" -gt '0' ] && \echo timeout "$ipset_timeout"; })
}

create_ipset_privaddr() {
    local ipset_setfamily=$(ipset_family $1)
    local privaddr_setname=$(setname_privaddr $1)
    is_setname_exists "$privaddr_setname" || \
    \ipset -N -exist "$privaddr_setname" hash:net family "$ipset_setfamily" \
        $({ [ "$ipset_timeout" -gt '0' ] && \echo timeout "$ipset_timeout"; })
}

create_ipset() {
    local grep_pattern=$({ is_ipv4_ipts $1 && \echo "$IPV4_NET_PATTERN" || \echo "$IPV6_NET_PATTERN"; })
    local privaddr_setname=$(setname_privaddr $1)
    local gfwlist_setname=$(setname_gfwlist $1)

    local privaddr_array=()
    is_ipv4_ipts $1 && privaddr_array=("${IPV4_RESERVED_IPADDRS[@]}") || privaddr_array=("${IPV6_RESERVED_IPADDRS[@]}")

    if is_global_mode || is_chnroute_mode; then
        create_ipset_privaddr $1

        for privaddr in "${privaddr_array[@]}"; do \echo "-A $privaddr_setname $privaddr"; done | \ipset -R -exist &>/dev/null
        \grep -ioE "$grep_pattern" "$file_ignlist_ext" | awk "{print \"-A ${privaddr_setname} \"$1}" | ipset -R -exist &>/dev/null

        is_chnroute_mode && create_ipset_chnroute $1

    elif is_gfwlist_mode; then
        create_ipset_gfwlist $1
        \grep -ioE "$grep_pattern" "$file_gfwlist_ext" | awk "{print \"-A ${gfwlist_setname} \"$1}" | \ipset -R -exist &>/dev/null
    fi
}

start_ipset() {
    is_true "$ipv4" && create_ipset -4
    is_true "$ipv6" && create_ipset -6
}

# return code
# 1:URI error
# 2:configuraion error
# 3:hostname resolve error
start_proxyserver() {
    check_proxy_env

    local uri= schema= has_true=false
    for uri_var_name in ${__proxy_uri_list[@]}; do
        uri="${!uri_var_name}"
        schema=$(parse_schema "$proxy_uri")

        [ -z "$schema" ] && log_error "$uri_var_name invalid"

        is_ss    "$schema" && parse_ss    "$uri" && start_ssr
        is_ssr   "$schema" && parse_ssr   "$uri" && start_ssr
        is_v2ray "$schema" && parse_vmess "$uri" && start_v2ray

        case "$?" in
            1)   log_error "uri invalid.";;
            2)   log_error "configuration error";;
            3)   log_error "hostname resolve error";;
            0)   has_true=true;;
            *)   log_error "unknown error";;
        esac
    done

    is_true $has_true && update_pidfile
}

stop_proxyserver() {
    [ '0' -lt "$status_v2ray_pid" ]      && kill $status_v2ray_pid       &>/dev/null
    [ '0' -lt "$status_ss_pid" ]         && kill $status_ss_pid          &>/dev/null
}

start_ssr() {
    status_ss_pid=$($bin_ssr -c "$ssr_config_file" &>/dev/null & \echo $! || \
    log_error "shadowsocks.conf error, can't start shadowsocks!";)
}

start_v2ray() {
    status_v2ray_pid=$($bin_v2ray -config "$v2ray_config_file" &>/dev/null & \echo $! || \
    log_error "V2ray.conf error, can't start V2ray!";)
}

parse_proxy() {
    proxy_uri="$1"
    __proxy_schema=$(parse_schema "$1")
    { ! is_ss && ! is_ssr && ! is_v2ray; } && log_fault "unsupport proxy schema: $__proxy_schema"

    stop_proxyserver
    start_proxyserver

    save_config "$ss_tproxy_config" -a proxy_uri "'$proxy_uri'"

    \echo $(color_white $(\printf "%-15s" "parse success:"))

    print_proxy_status
}

parse_ssr() {
    chk_base64
    local ssr_config=$(\sed '{s/ssr:\/\///g;s/-/+/g;s/_/\//g;}' <<<"$1" | $bin_base64_decode 2>/dev/null)
    [ -n "$ssr_config" ] || return 1

    local ssr_srvhost=$(\cut -d: -f1 <<<"$ssr_config")
    local ssr_srvport=$(\cut -d: -f2 <<<"$ssr_config")
    local ssr_protocol=$(\cut -d: -f3 <<<"$ssr_config")
    local ssr_method=$(\cut -d: -f4 <<<"$ssr_config")
    local ssr_obfs=$(\cut -d: -f5 <<<"$ssr_config")
    local and_param=$(\cut -d: -f6 <<<"$ssr_config" | \sed '{s#/\|?\|/?#:#;s/-/+/g;s/_/\//g;}')
    local ssr_passwd="$(\cut -d: -f1 <<<"$and_param" | $bin_base64_decode 2>/dev/null)"
    local ssr_params="$(\cut -d: -f2 <<<"$and_param")"
    local ssr_obfs_param=$(url_query obfsparam "$ssr_params" | $bin_base64_decode 2>/dev/null)
    local ssr_proto_param=$(url_query protoparam "$ssr_params" | $bin_base64_decode 2>/dev/null)
    local ssr_remarks=$(url_query remarks "$ssr_params" | $bin_base64_decode 2>/dev/null)
    local ssr_group=$(url_query group "$ssr_params" | $bin_base64_decode 2>/dev/null)
    local ssr_loaddr=$(get_listen_addr)
    local ssr_ip4=
    local ssr_ip6=

    if is_true "$ipv6"; then
        ssr_ip4=$(resolve_hostname6 "$ssr_srvhost")
        is_ipv6_address $ssr_ip4 || ssr_ip4=
    else
        ssr_ip4=$(resolve_hostname4 "$ssr_srvhost")
        is_ipv4_address $ssr_ip4 || ssr_ip4=
    fi

    [ -z "${ssr_ip4}" -a "$ssr_ip6" ] && return 3

    local ssr_config='{"server":"'$ssr_srvhost'","server_port":"'$ssr_srvport'","local_addressr":"'$ssr_loaddr'","local_port":"'$proxy_tcpport'","encrypt_method":"'$ssr_method'","passrword":"'$ssr_passwd'","protocol":"'$ssr_protocol'","protocolparam":"'$ssr_proto_param'","obfs":"'$ssr_obfs'","obfsparam":"'$ssr_obfs_param'","remarks":"'$ssr_remarks'","group":"'$ssr_group'"}'

    local tmp_file=$(\mktemp)

    \jq . <<<"${ssr_config}" >$tmp_file || return 2

    [ -n "$ssr_ip4" ] && proxy_srvadd4+=("$ssr_ip4")
    [ -n "$ssr_ip6" ] && proxy_srvadd6+=("$ssr_ip6")
    proxy_srvaddr4=($(uniq_array "${proxy_srvaddr4[*]}"))
    proxy_srvaddr6=($(uniq_array "${proxy_srvaddr6[*]}"))

    save_config "$ss_tproxy_config" \
        proxy_srvaddr4 "($proxy_srvaddr4[*])" \
        proxy_srvaddr6 "($proxy_srvaddr6[*])" \
        proxy_srvport "$ssr_srvport"

    \mv $tmp_file "$ssr_config_file" && \
    \echo "shadowsocks.conf resolve" $(color_green "succeed !!")
}

parse_ss() {
    chk_base64
    local ss_config=$(\sed -e '{s/ss:\/\///g;s/-/+/g;s/_/\//g;}' <<<"$1" | $bin_base64_decode 2>/dev/null)
    [ -n "$ss_config" ] || return 1

    local ss_srvhost=$(\cut -d@ -f2 <<<"$ss_config" | \cut -d: -f1)
    local ss_srvport=$(\cut -d@ -f2 <<<"$ss_config" | \cut -d: -f2)
    local ss_method=$(\cut -d@ -f1 <<<"$ss_config" | \cut -d: -f1)
    local ss_passwd="$(\cut -d@ -f1 <<<"$ss_config" | \cut -d: -f2)"
    local ss_loaddr=$(get_listen_addr)
    local ss_fastopen='false'
    local ss_timeout='0'
    local ss_ip4=
    local ss_ip6=

    if is_true "$ipv6"; then
        ss_ip6=$(resolve_hostname6 "$ss_srvhost")
        is_ipv6_address $ss_ip6 || ss_ip6=
    else
        ss_ip4=$(resolve_hostname4 "$ss_srvhost")
        is_ipv4_address $ss_ip4 || ss_ip4=
    fi

    [ -z "${ss_ip4}" -a "$ss_ip6" ] && return 3

    local ss_config='{"server":"'$ss_srvhost'","server_port":"'$ss_srvport'","local_address":"'$ss_loaddr'","local_port":"'$proxy_tcpport'","encrypt_method":"'$ss_method'","password":"'$ss_passwd'"}'

    local tmp_file=$(\mktemp)

    \jq . <<<"${ss_config}" >$tmp_file || return 2

    [ -n "$ss_ip4" ] && proxy_srvadd4+=("$ss_ip4")
    [ -n "$ss_ip6" ] && proxy_srvadd6+=("$ss_ip6")
    proxy_srvaddr4=($(uniq_array "${proxy_srvaddr4[*]}"))
    proxy_srvaddr6=($(uniq_array "${proxy_srvaddr6[*]}"))

    save_config "$ss_tproxy_config" \
        proxy_srvaddr4 "($proxy_srvaddr4[*])" \
        proxy_srvaddr6 "($proxy_srvaddr6[*])" \
        proxy_srvport "$ss_srvport"

    \mv $tmp_file "$ssr_config_file" && \
    \echo "shadowsocks.conf configuration" $(color_green "succeed")
}

parse_vmess() {
    chk_base64
    # base64 decode
    local vmess_config=$(\sed -e '{s/vmess:\/\///g;s/-/+/g;s/_/\//g;}' <<<"$1" | $bin_base64_decode 2>/dev/null | \jq -c  .)
    [ -n "$vmess_config" ] || return 1

    local vmess_add=$(\echo "$vmess_config"  | \jq -cr .add)
    local vmess_port=$(\echo "$vmess_config" | \jq -cr .port)
    local vmess_id=$(\echo "$vmess_config"   | \jq -cr .id)
    local vmess_aid=$(\echo "$vmess_config"  | \jq -cr .aid)
    local vmess_net=$(\echo "$vmess_config"  | \jq -cr .net)
    local vmess_type=$(\echo "$vmess_config" | \jq -cr .type)
    local vmess_host=$(\echo "$vmess_config" | \jq -c .host)
    local vmess_path=$(\echo "$vmess_config" | \jq -cr .path)
    local vmess_tls=$(\echo "$vmess_config"  | \jq -cr .tls)
    local vmess_loaddr=$(get_listen_addr)
    local vmess_ip4=
    local vmess_ip6=

    if is_true "$ipv6"; then
        vmess_ip6=$(resolve_hostname6 "$vmess_add")
        is_ipv6_address $vmess_ip6 || vmess_ip6=
    else
        vmess_ip4=$(resolve_hostname4 "$vmess_add")
        is_ipv4_address $vmess_ip4 || vmess_ip4=
    fi

    [ -z "${vmess_ip4}" -a -z "$vmess_ip6" ] && return 3
    [[ "$vmess_path" == '' ]] && vmess_path="null"
    [[ "$vmess_net" != 'quic' ]] && vmess_host=$(\sed 's/,/","/g' <<<"$vmess_host")

    is_domain_name "$vmess_add" && dnsmasq_conf_string+=("address = /$vmess_add/$vmess_ip4")

    ## outBounds
    out_set='{"vnext":[{"address":"'${vmess_add}'","port":'${vmess_port}',"users":[{"id":"'${vmess_id}'","security":"auto","alterId": '${vmess_aid}'}]}]}'
    out_stream='{"network":"'${vmess_net}'","security":"none"}'

    case ${vmess_net} in
        'tcp')
            out_stream=$(\echo "$out_stream" | \jq -c '. | {network, security, "tcpSettings":{}}')
            ;;
        'kcp')
            out_stream=$(\echo "$out_stream" | \jq -c '. | {network, security, "kcpSettings":{}}')
            ;;
        'ws')
            ws_settings='{"path":"'${vmess_path}'"}'
            [[ "$vmess_host" != '""' ]] && ws_settings=$(\echo ${ws_settings} | \jq -c '. += {"headers":{"host":'${vmess_host}'}}');
            out_stream=$(\echo "$out_stream" | \jq -c '. | {network, security, "wsSettings": '${ws_settings}'}')
            ;;
        'h2')
            out_stream=$(\echo "$out_stream" | \jq -c '. | {network, security, "httpSettings":{"path":"'${vmess_path}'","host":['${vmess_host}']}}')
            ;;
        'quic')
            out_stream=$(\echo "$out_stream" | \jq -c '. | {network, security, "quicSettings":{"security":'${vmess_host}',"key":"'${vmess_path}'","header":{"type": "none"}}}')
            ;;
    esac

    if [ "$vmess_tls" == 'tls' ]; then
        [ "$vmess_host" == '""' ] && vmess_host="null"
        out_stream=$(\echo "$out_stream" | \jq -c '. += {"tlsSettings":{"allowInsecure":true,"serverName":"'${vmess_host}'"}} | to_entries | map(if .key == "security" then . + {"value":"tls"} else . end ) | from_entries')
    fi
    local outbound='[{"protocol":"vmess","settings":'${out_set}',"tag": "out-0","streamSettings":'${out_stream}'}]'

    ## inBounds
    [ "${tproxy}" == 'true' ] && proxy_vmess_tproxy='"tproxy"' || proxy_vmess_tproxy='"redirect"'

    \grep -qE '^[0-9][0-9]+$' <<<"$proxy_tcpport" || proxy_tcpport=60080
    \grep -qE '^[0-9][0-9]+$' <<<"$proxy_udpport" || proxy_udpport=60080

    local in_stream='{"sockopt":{"mark":0,"tcpFastOpen":true,"tproxy":'${proxy_vmess_tproxy}'}}'
    local inbound;

    if [[ "$proxy_tcpport" != "$proxy_udpport" ]]; then
        inbound='[{"protocol":"dokodemo-door","listen":"'${vmess_loaddr}'","port":'${proxy_tcpport}',"settings":{"network": "tcp","followRedirect":true },"streamSettings":'${in_stream}'},{"protocol":"dokodemo-door","listen":"'${vmess_loaddr}'","port":'${proxy_udpport}',"settings":{"network": "udp","followRedirect":true },"streamSettings":'${in_stream}'}]'
    else
        inbound='[{"protocol":"dokodemo-door","listen":"'${vmess_loaddr}'","port":'${proxy_tcpport}',"settings":{"network": "tcp,udp","followRedirect":true },"streamSettings":'${in_stream}'}]'
    fi

    ## v2ray log
    local v_log='{"loglevel": "'${proxy_log_level}'","error": "'${proxy_log_file}'","access": "'${proxy_log_file}'"}'

    local v2ray_config='{"log":'${v_log}',"dns":{},"stats":{},"inbounds":'${inbound}',"outbounds":'${outbound}',"routing":{},"policy":{},"reverse":{},"transport":{}}'

    local tmp_file=$(\mktemp)
    \jq . <<<"${v2ray_config}" >$tmp_file || return 2

    "$bin_v2ray" -test -config $tmp_file | \grep -qF 'Configuration OK' || return 2

    [ -n "$vmess_ip4" ] && proxy_srvaddr4+=("$vmess_ip4")
    [ -n "$vmess_ip6" ] && proxy_srvaddr6+=("$vmess_ip6")
    proxy_srvaddr4=($(uniq_array "${proxy_srvaddr4[*]}"))
    proxy_srvaddr6=($(uniq_array "${proxy_srvaddr6[*]}"))

    # save config
    save_config "$ss_tproxy_config" \
        proxy_tcpport "$proxy_tcpport" \
        proxy_udpport "$proxy_udpport" \
        proxy_srvaddr4 "(${proxy_srvaddr4[*]})" \
        proxy_srvaddr6 "(${proxy_srvaddr6[*]})" \
        proxy_srvport "$vmess_port" \
        -e opts_ip_for_check_net "$vmess_ip4"

    \mv $tmp_file "$v2ray_config_file" && \
    \echo "v2ray.conf configuration" $(color_green "succeed")
}

do_proxy() {
    local action=$1
    shift
    case "$action" in
        pa|parse)       parse_proxy "${@}";;
        a|add) ;;
        d|del|delete) ;;
    esac
}

_add_delete_domain() {
    local action="$1";
    local domain="$2";
	local file_name="$3";
    local customfile_name="$4";
    local ipset_name=;
	local dns_name=;

    ! is_domain_name "$domain" || \
    ! is_ipv6_address "$domain" || \
    ! is_ipv4_address "$domain" || \
    ! grep -qE "$IPV4_NET_PATTERN" || \
    ! grep -qE "$IPV6_NET_PATTERN" || \
    { \echo $(color_red "invalid domain $domain") && return 1; }

    if is_global_mode || is_chnroute_mode; then
        is_true $ipv4 && ipset_name=${ipset_privaddr_name}  && dns_name=$dns_direct
        is_true $ipv6 && ipset_name=${ipset_privaddr_name}6 && dns_name=$dns_direct6
    elif is_gfwlist_mode; then
        is_true $ipv4 && ipset_name=${ipset_gfwlist_name}  && dns_name=$dns_remote
        is_true $ipv6 && ipset_name=${ipset_gfwlist_name}6 && dns_name=$dns_remote6
    fi

    [ -n "$ipset_name" ] || log_fault "ipset name error"

    if [ "$action" = "add" ]; then
        if [ -n "$file_name" ] && is_domain_name $domain; then
            \grep -qE "^${domain}$" "$customfile_name" && \echo $(color_red "domain $domain exists") && return 1
            \grep -qF "/$domain/" "$file_name"         && \echo $(color_red "domain $domain exists") && return 1

            \echo "$domain" >>"$customfile_name"
            \echo -e "server = /$domain/$dns_name\nipset  = /$domain/$ipset_name"   >>"$file_name"
        fi
        \ipset add -exist $ipset_name "$domain"

        \echo "domain added" $(color_green "$domain")
    elif [ "$action" = "delete" ]; then
        if [ -n "$file_name" ] && is_domain_name $domain; then
            \sed -ie "/^${domain}\$/d" "$customfile_name"
            \sed -ie "/\/${domain}\//d" "$file_name"
        fi
        \ipset del -exist  $ipset_name "$domain"

        \echo "domain deleted" $(color_red "$domain")
    fi
}

do_modify_gfwlist() {
    local action="$1";shift;

    is_true "$ipv4" && create_ipset_gfwlist -4
    is_true "$ipv6" && create_ipset_gfwlist -6

    if [ '-' = "$*" ]; then
        while read domain; do _add_delete_domain $action $domain "$dnsmasq_gfwlist_file" "$file_gfwlist_ext"; done
    else
        for domain in "$@"; do _add_delete_domain $action $domain "$dnsmasq_gfwlist_file" "$file_gfwlist_ext"; done
    fi

	reload_dnsserver
}

do_modify_ignlist() {
    local action="$1";shift;

    is_true "$ipv4" && create_ipset_privaddr -4
    is_true "$ipv6" && create_ipset_privaddr -6

    if [ '-' = "$*" ]; then
        while read domain; do _add_delete_domain $action $domain "$dnsmasq_ignore_file" "$file_ignlist_ext"; done
    else
        for domain in "$@"; do _add_delete_domain $action $domain "$dnsmasq_ignore_file" "$file_ignlist_ext"; done
    fi

	reload_dnsserver
}

test_domain_status() {
    local action=$1 ipset_name=
    local files=()
    shift

    if is_global_mode || is_chnroute_mode; then
        is_true $ipv4 && ipset_name=${ipset_privaddr_name}
        is_true $ipv6 && ipset_name=${ipset_privaddr_name}6
    elif is_gfwlist_mode; then
        is_true $ipv4 && ipset_name=${ipset_gfwlist_name}
        is_true $ipv6 && ipset_name=${ipset_gfwlist_name}6
    fi

    [ "$action" = 'all' -o "$action" = 'gfwlist' ] && files+=("$dnsmasq_gfwlist_file") && files+=("$file_gfwlist_ext")
    [ "$action" = 'all' -o "$action" = 'ignlist' ] && files+=("$dnsmasq_ignore_file") && files+=("$file_ignlist_ext")

    [ -z "$ipset_name" ] && log_fault "ipset name error"

    _test_domain_status() {
        \echo -en $(color_white "$1: ")
        if is_domain_name "$1"; then
            \grep -qE "^${1}$|/${1}/" ${files[*]} &>/dev/null && \echo $(color_green "exists") && continue
        elif is_ipv4_net $1 || is_ipv6_net $1; then
            \ipset test $ipset_name "$1" &>/dev/null && \echo $(color_green "exists") && continue
        fi
        \echo $(color_yellow "not exist")
    }

    if [ '-' = "$*" ]; then
        while read domain; do _test_domain_status $domain; done
    else
        for domain in "${@}"; do _test_domain_status $domain; done
    fi
}

domain_delete() {
    local list=$1
    shift
    case "$list" in
        ''|gfw|gfwlist)
            do_modify_gfwlist delete "${@}"
        ;;
        ign|ignore|ignlist)
            do_modify_ignlist delete "${@}"
        ;;
        -h|--help|h|help)
            \echo "Usage: $bin domain delete" $(color_white "[LIST] DOMAIN...");
            \echo
            \echo "[LIST]: " $(color_white "gfwlist")'|'$(color_white "ignlist");
            \echo
            \echo "When DOMAIN is '-', read standard input";
        ;;
        *)
            \echo $(color_yellow "unknown command:") $(color_red "$list");\
            \echo $(color_white "try \"$bin domain delete help\"");
            exit 1
        ;;
    esac
}

domain_add() {
    local list=$1
    shift
    case "$list" in
        ''|gfw|gfwlist)
            do_modify_gfwlist add "${@}"
        ;;
        ign|ignore|ignlist)
            do_modify_gfwlist add "${@}"
        ;;
        -h|--help|h|help)
            \echo "Usage: $bin domain add" $(color_white "[LIST] DOMAIN...");
            \echo
            \echo "[LIST]: " $(color_white "gfwlist")'|'$(color_white "ignlist");
            \echo
            \echo "When DOMAIN is '-', read standard input";
        ;;
        *)
            \echo $(color_yellow "unknown command:") $(color_red "$list");\
            \echo $(color_white "try \"$bin domain add help\"");
            exit 1
        ;;
    esac
}
domain_test() {
    local list=$1
    case "$list" in
        gfw|gfwlist)
            shift
            test_domain_status gfwlist "${@}"
        ;;
        ign|ignore|ignlist)
            shift
            test_domain_status ignlist "${@}"
        ;;
        ''|-h|--help|h|help)
            \echo "Usage: $bin domain test" $(color_white "[LIST] DOMAIN...");
            \echo
            \echo "[LIST]: " $(color_white "gfwlist")'|'$(color_white "ignlist");
            \echo
            \echo "When DOMAIN is '-', read standard input";
        ;;
        *)
            test_domain_status all "${@}"
        ;;
    esac
}

do_domain() {
    local action=$1
    shift
    case "$action" in
        a|add)      domain_add "${@}";;
        d|del)      domain_delete "${@}";;
        t|test)     domain_test "${@}";;
        ''|-h|--help|h|help)
            \echo "Usage: $bin domain" $(color_white "<ACTION> [LIST] DOMAIN...");
            \echo
            \echo "<ACTION>: " $(color_white "add")'|'$(color_white "delete");
            \echo "[LIST]: " $(color_white "gfwlist")'|'$(color_white "ignlist");
            \echo
            \echo "When DOMAIN is '-', read standard input";
        ;;
        *)
            \echo $(color_yellow "unknown command:") $(color_red "$action");\
            \echo $(color_white "try \"$bin domain help\"");
            exit 1
        ;;
    esac
}

do_set_mode() {
    [ "$mode" = "$1" ] && return 0;
    [ "$1" != "global" -o "$1" != "gfwlist" -o "$1" != "chnroute" ] && log_fault "mode $1 not support"
    mode="$1"
    save_config "$ss_tproxy_config" mode $mode

    do_stop
    do_start
}

start_dnsserver() {
    check_dnsmasq_env
    restore_resolvconf
    trigger_proxy_startcmd
    start_dnsmasq_daemon
    modify_resolvconf
}

do_show() {
    case "$1" in
        ipt|iptables)
            do_show_iptables
        ;;
        ''|-h|--help|h|help)
            \echo "Usage: $bin show" $(color_white "[SERVICE]");
            \echo "       $bin show" $(color_white "iptables");
        ;;
        *)
            \echo $(color_yellow "unknown service:") $(color_red "$1");\
            \echo $(color_white "try \"$bin update help\"");
            exit 1
        ;;
    esac
}

do_update() {
    local srv=$1
    shift
    case "$srv" in
        gfw|gfwlist)
            do_update_gfwlist "${@}"
            ;;
        chn|chnlist)
            do_update_chnlist "${@}"
            ;;
        chnroute)
            do_update_chnroute "${@}"
            ;;
        ''|-h|--help|h|help)
            \echo "Usage: $bin update" $(color_white "[SERVICE]");
            \echo "       $bin update" $(color_white "gfwlist");
            \echo "       $bin update" $(color_white "chnlist");
            \echo "       $bin update" $(color_white "chnroute");
        ;;
        a|all)
            do_update gfwlist
            do_update chnlist
            do_update chnroute
        ;;
        *)
            \echo $(color_yellow "unknown service:") $(color_red "$srv");\
            \echo $(color_white "try \"$bin update help\"");
            exit 1
        ;;
    esac
}

do_start() {
    local srv="$1"
    case "$srv" in
        p|proxy)
            chk_proxyserver_is_started || {
                start_proxyserver
            }
        ;;
        d|dns|dnsmasq)
            process_is_running $status_dnsmasq_pid || {
                waiting_network "$opts_ip_for_check_net"
                start_dnsserver
            }
        ;;
        i|ipt|iptables)
            chk_proxyserver_is_started || log_fault "proxy is stoped. please start proxy first."
            chk_iptables_is_started || {
                enable_ipforward
                disable_icmpredir
                start_iptables
            }
        ;;
        ipset)
            start_ipset
        ;;
        -h|--help|h|help)
            \echo "Usage: $bin start" $(color_white "[SERVICE]");
            \echo "       $bin start" $(color_white "proxy");
            \echo "       $bin start" $(color_white "dnsmasq");
            \echo "       $bin start" $(color_white "iptables");
            \echo "       $bin start" $(color_white "ipset");
        ;;
        '')
            check_proxy_env
            check_iptable_env

            [ "$(type -t pre_start)" = 'function' ] && pre_start "$@"
            do_start dnsmasq
            do_start proxy
            do_start iptables
            [ "$(type -t post_start)" = 'function' ] && post_start "$@"
        ;;
        *)
            \echo $(color_yellow "unknown service:") $(color_red "$srv");\
            \echo $(color_white "try \"$bin start help\"");
            exit 1
        ;;
    esac
}

do_stop() {
    local srv="$1"

    case "$srv" in
        p|proxy)
            chk_iptables_is_started && log_fault "must stop iptables first"
            chk_proxyserver_is_started && {
                stop_proxyserver
            }
        ;;
        d|dns|dnsmasq)
            process_is_running $status_dnsmasq_pid && {
                restore_resolvconf
                stop_dnsserver
                trigger_proxy_stopcmd
            }
        ;;
        i|ipt|iptables)
            chk_iptables_is_started && {
                delete_iproute2
                do_stop_iptables
            }
        ;;
        ipset)
            { chk_proxyserver_is_started || chk_iptables_is_started; } && log_fault "ipset is used, stop failed"
            delete_ipset_chnroute
            delete_ipset_gfwlist
        ;;
        -h|--help|h|help)
            \echo "Usage: $bin stop" $(color_white "[SERVICE]");
            \echo "       $bin stop" $(color_white "proxy");
            \echo "       $bin stop" $(color_white "dnsmasq");
            \echo "       $bin stop" $(color_white "iptables");
            \echo "       $bin stop" $(color_white "ipset");
        ;;
        '')
            [ "$(type -t pre_stop)" = 'function' ] && pre_stop "$@"
            do_stop iptables
            do_stop dnsmasq
            do_stop proxy
            do_stop ipset
            [ "$(type -t post_stop)" = 'function' ] && post_stop "$@"
        ;;
        *)
            \echo $(color_yellow "unknown service:") $(color_red "$srv");\
            \echo $(color_white "try \"$bin stop help\"");
            exit 1
        ;;
    esac
}

reload_dnsserver() {
    process_is_running $status_dnsmasq_pid || log_fault "dnsmasq is not running"

    _flush_dnscache && \
    \echo -n "reload dnsmasq: " && \
    \echo $(color_green "success") || \
    \echo $(color_red "failed")
}

reload_proxyserver() {
    stop_proxyserver
    start_proxyserver && \
    {
        \echo -n "reload "
        is_ss       && \echo -n " ss ";
        is_ssr      && \echo -n " ssr ";
        is_v2ray    && \echo -n " v2ray ";
        \echo -n ':';
    } && \
    \echo $(color_green "success") || \
    \echo $(color_red "failed")
}

reload_iptables() {
    delete_iproute2
    do_stop_iptables
    delete_ipset_chnroute

    do_start iptables
}

do_reload() {
    local srv=$1
    case "$srv" in
        d|dns|dnacache|dnsmasq)
            reload_dnsserver
            ;;
        ipt|iptables)
            reload_iptables
            ;;
        ipset)
            do_flush_ipset
            ;;
        -h|--help|h|help)
            \echo "Usage: $bin reload" $(color_white "[SERVICE]");
            \echo "       $bin reload" $(color_white "[SERVICE]");
            \echo "       $bin reload" $(color_white "dnsmasq");
            exit
            ;;
        '')
            reload_dnsserver;
            reload_iptables
            ;;
        *)
            \echo $(color_yellow "unknown service:") $(color_red "$srv");\
            \echo $(color_white "try \"$bin reload help\"");
            exit 1
            ;;
    esac
    exit
}

do_status() {
    local max=15

    \printf "%-${max}s%s\n" "mode:" $mode

    if [ -n "$__proxy_schema" ]; then
        is_v2ray && {
        process_is_running $status_v2ray_pid && \
        \printf "%-${max}s%s %s\n" "v2ray/tcp:" $(color_green '[running]') "($(print_proxy_status))" || \
        \printf "%-${max}s%s\n" "v2ray/tcp:" $(color_red '[stopped]');
        }
        is_ssr   && {
        process_is_running $status_ss_pid && \
        \printf "%-${max}s%s %s\n" "ssr/tcp:" $(color_green '[running]') "($(print_proxy_status))" || \
        \printf "%-${max}s%s\n" "ssr/tcp:" $(color_red '[stopped]')
        }
        is_ss   && {
        process_is_running $status_ss_pid && \
        \printf "%-${max}s%s %s\n" "ss /tcp:" $(color_green '[running]') "($(print_proxy_status))" || \
        \printf "%-${max}s%s\n" "ss /tcp:" $(color_red '[stopped]')
        }
    fi
    tcp_port_is_exists $proxy_tcpport && \
        \printf "%-${max}s%s\n" "pxy/tcp:" $(color_green '[running]') || \
        \printf "%-${max}s%s\n" "pxy/tcp:" $(color_red '[stopped]')

    if is_enabled_udp; then
        udp_port_is_exists $proxy_udpport && \
        \printf "%-${max}s%s\n" "pxy/udp:" $(color_green '[running]') || \
        \printf "%-${max}s%s\n" "pxy/udp:" $(color_red '[stopped]')
    fi

    chk_iptables_is_started && \
        \printf "%-${max}s%s\n" "iptables:" $(color_green '[configured]') || \
        \printf "%-${max}s%s\n" "iptables:" $(color_red '[deleted]')

    process_is_running $status_dnsmasq_pid && \
        \printf "%-${max}s%s\n" "dnsmasq:" $(color_green '[running]') || \
        \printf "%-${max}s%s\n" "dnsmasq:" $(color_red '[stopped]')
    if is_chnroute_mode; then
        process_is_running $status_chinadns_pid && \
        \printf "%-${max}s%s\n" "chinadns:" $(color_green '[running]')|| \
        \printf "%-${max}s%s\n" "chinadns:" $(color_red '[stopped]')
    fi
    if ! is_enabled_udp; then
        is_true "$ipv4" && { process_is_running $status_dns2tcp4_pid && \
        \printf "%-${max}s%s\n" "dns2tcp4:" $(color_green '[running]') || \
        \printf "%-${max}s%s\n" "dns2tcp4:" $(color_red '[stopped]');
        }
        is_true "$ipv6" && { process_is_running $status_dns2tcp6_pid && \
        \printf "%-${max}s%s\n" "dns2tcp6:" $(color_green '[running]') || \
        \printf "%-${max}s%s\n" "dns2tcp6:" $(color_red '[stopped]');
         }
    fi
}

do_flush_ipset() {
    case "$1" in
        gfw|gfwlist)
            flush_ipset_gfwlist
            ;;
        chn|chnroute)
            flush_ipset_chnroute
            ;;
        help)
            \echo "Usage: $bin flush ipset" $(color_white "[SERVICE]");
            \echo "       $bin flush ipset" $(color_white "gfwlist");
            \echo "       $bin flush ipset" $(color_white "chnroute");
            exit
            ;;
        '')
            do_flush_ipset chnroute;
            do_flush_ipset gfwlist;
            ;;
        *)
            \echo $(color_yellow "unknown service:") $(color_red "$1");\
            \echo $(color_white "try \"$bin flush ipset help\"");
            exit 1
            ;;
    esac
    exit
}

do_flush() {
    local srv=$1
    shift
    case "$srv" in
        ipset)
            do_flush_ipset ${@}
            ;;
        ipt|iptables)
            do_stop_iptables
            ;;
        ip|iproute)
            delete_iproute2
            ;;
        d|dns|dnscache|dnsmasq)
            reload_dnsserver
            ;;
        help)
            \echo "Usage: $bin flush" $(color_white "[SERVICE]");
            \echo "       $bin flush" $(color_white "ipset");
            \echo "       $bin flush" $(color_white "iptables");
            \echo "       $bin flush" $(color_white "iproute");
            exit
            ;;
        '')
            reload_dnsserver;
            reload_proxyserver
            ;;
        *)
            \echo $(color_yellow "unknown service:") $(color_red "$srv");\
            \echo $(color_white "try \"$bin flush help\"");
            exit 1
            ;;
    esac
    exit
}

do_statistic() {
    local ip_ln=() ip6_ln=()
    local ip_lst=() ip6_lst=()
    local ip_nums=

    if is_true "$ipv4"; then
        ip_nums=$(iptables -4 -nL OUTPUT --line-number | \awk '/^[0-9]/{print $1,$5}')
        for srv_addr in ${proxy_srvaddr4[@]}; do
            ip4_ln+=("$(\grep -F "$srv_addr" <<<"$ip_nums" | \cut -d' ' -f1)");
            ip4_lst+=("$srv_addr")
        done
    fi
    if is_true "$ipv6"; then
        ip_nums=$(iptables -6 -nL OUTPUT --line-number | \awk '/^[0-9]/{print $1,$5}')
        for srv_addr in ${proxy_srvaddr6[@]}; do
            ip6_ln+=("$(\grep -iF "$srv_addr" <<<"$ip_nums" | \cut -d' ' -f1)");
            ip6_lst+=("$srv_addr")
        done
    fi
    local total_count=
    let total_count=${#ip4_ln[@]}+${#ip6_ln[@]}

    while 'true'; do
        awk '
{
    if(NR<='$total_count'){
        a[$8]=$2;
    } else {
        b[$8]=$2;
    }
}
END {
    for(ip in a) {
        m="B/s";
        t=b[ip] - a[ip];
        if (t>1024) { t=t/1024; m="KB/s";}
        if (t>1024) { t=t/1024; m="MB/s";}
        if (t>1024) { t=t/1024; m="GB/s";}
        printf "%20s:%6.1f%4s\r", ip, t, m;
    }
}' <<<"$({
        for line in ${ip4_ln[@]}; do iptables -4 -xnvL OUTPUT $line; done;
        for line in ${ip6_ln[@]}; do iptables -6 -xnvL OUTPUT $line; done;
        sleep 1
        for line in ${ip4_ln[@]}; do iptables -4 -xnvL OUTPUT $line; done;
        for line in ${ip6_ln[@]}; do iptables -6 -xnvL OUTPUT $line; done;
        })"
    done
}

do_version() {
    \echo "ss-tproxy v5.3.1"
    exit
}

do_help() {
    \cat <<EOF
Usage: $bin <COMMAND> [-x] [-c cfgfile] [name=value...]
COMMAND := {
    start               start ss-tproxy
    stop                stop ss-tproxy
    restart             restart ss-tproxy
    reload              reload configure
    status              status of ss-tproxy
    show                show rules
    flush               delete rules

    update              update domain list
    parse               config proxy from URI

    set-mode            change run mode manual

    domain              add/delete domains

    version             show version and exit
    help                show help and exit
}
Specify the -x option for debugging of bash scripts
Specify the -c option to use given ss-tproxy cfgfile
Specify the name=value to override ss-tproxy configs
Issues or bug report: https://github.com/zwcway/ss-tproxy
EOF
    exit
}

main() {
    local arguments=()

    local arglist=("$@")
    local help_flag=false ver_flag=false
    for ((i = 0; i < ${#arglist[@]}; ++i)); do
        local arg="${arglist[i]}"
        if [ "$arg" = '-x' ]; then
            set -x
        elif [ "$arg" = '-c' ]; then
            ss_tproxy_config="${arglist[++i]}"
            base_dir="${ss_tproxy_config%/*}"
        elif [ "$arg" = '-v' ]; then
            ver_flag=true
        elif [ "$arg" = '-h' ]; then
            help_flag=true
        elif [[ "$arg" = '--' ]]; then
            break
        elif [[ "$arg" =~ ^= ]]; then
            \echo $(color_yellow "unknown option: ") $(color_red "$arg")
            do_help
        elif \grep -qF '=' <<<"$arg"; then
            __optentries+=("$arg")
        else
            arguments+=("$arg")
        fi
    done

    is_true $help_flag && do_help
    is_true $ver_flag && do_version

    if [ "${#arguments[@]}" -eq 0 -a "${#__optentries[@]}" -eq 0 ]; then
        \echo "$(color_yellow "Missing necessary options")"
        do_help
    fi

    load_config "$@"
    check_config
    check_env

    [ "${#arguments[@]}" -eq 0 ] && return;

    case "${arguments[0]}" in
        start)                          do_start "${arguments[@]:1}"; do_status;;
        stop)                           do_stop "${arguments[@]:1}"; do_status;;
        restart)                        do_stop "${arguments[@]:1}"; do_status; \echo; do_start "${arguments[@]:1}"; do_status;;
        s|status)                       do_status;;
        show)                           do_show "${arguments[@]:1}";;
        f|flush)                        do_flush;;
        r|reload)                       do_reload "${arguments[@]:1}";;
        u|update)                       do_update "${arguments[@]:1}";;

        proxy)                          do_proxy "${arguments[@]:1}";;
        statistic)                      do_statistic;;

        d|domain)                       do_domain "${arguments[@]:1}";;

        mode|set-mode)                  do_set_mode "${arguments[@]:1}";;
        v|version)                      do_version;;
        h|help)                         do_help;;
        *)                              \echo "$(color_yellow "Unknown option: ${arguments[0]}")"; do_help; return 1;;
    esac
    return 0
}
main "$@"
